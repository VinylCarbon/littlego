Purpose of this document
------------------------
This document describes the research I did before I started coding Little Go in
earnest.


Go Engines
----------
List of Go-playing programs: http://senseis.xmp.net/?GoPlayingPrograms

Aya
- http://www32.ocn.ne.jp/~yss/
- The program is labelled as "free software"
- The most recent version from 2008 is made available for download without
  source and for the Windows platform only
- Maybe the author could be persuaded to let me port the program to
  Mac OS X / iOS under a closed-source agreement?

NeuroGo
- http://webdocs.cs.ualberta.ca/~emarkus/neurogo/
- No source code, not even a downloadable binary

Fuego
- http://fuego.sourceforge.net/
- A library/framework for programming Go games, including a Go engine
- Released under LGPL v3, which unfortunately includes the redistribution
  clause(s) from the GPL v3
- This looks so promising that I might write to the developers (fuego-devel)
  with an inquiry as to whether they think I could include the library

SmartGo
- http://www.smartgo.com/en/index.htm
- Commercial product
- Already offers the iPhone applications "SmartGo" and "SmartGo Pro"; both apps
  cost money

Steenvreter, Magog and Migos
- http://erikvanderwerf.tengen.nl/
- These programs apparently solve go problems, they are not go playing engines
- I'm not sure if the source code of these programs is available

Explorer
- http://webdocs.cs.ualberta.ca/~mmueller/cgo/explorer.html
- Program is freeware
- Googling for "Explorer.sit.hqx" leads to the following download location
  ftp://ftp.icsi.berkeley.edu/pub/theory/mmueller/Explorer.sit.hqx
- The archive expands to a binary and a "Read me" file that explains that this
  is shareware
- The source code effectively is not available

Indigo
- http://www.mi.parisdescartes.fr/~bouzy/INDIGO.html
- Linux binary that understands GTP

Dave Dyer's Go Program
- http://www.andromeda.com/people/ddyer/go-program.html
- Doesn't play

Pachi
- http://repo.or.cz/w/pachi.git
- Player program and framework
- Licensed under GPLv2

Moyoman
- http://www.moyoman.org/
- Player program written in Java
- Not very far developed, and also not actively developed anymore (last release
  is 2004)
- Licensed under the Apache License 2.0


Licensing
---------
GPL licensed software cannot be used for iOS applications under the current
terms of services of the iTunes Store and the App Store. Period. There are two
articles on fsf.org that describe a case where GNU Go was distributed over the
App Store. The second article explains where the GPL conflicts with Apple's
terms of services.
- http://www.fsf.org/news/2010-05-app-store-compliance/
- http://www.fsf.org/news/blogs/licensing/more-about-the-app-store-gpl-enforcement

Another interesting article explains that it's ok from a legal point of view to
distribute GPL'ed software via the App Store if you have the copyright on the
software (i.e. you wrote the software yourself)
- http://bonsansnom.wordpress.com/2011/01/08/about-apple-store-gpls-vlc-and-betrains/

An article written by someone who believes that it's ok to use GPL'ed software:
- http://www.geoffeg.org/wordpress/2009/10/07/the-iphone-and-the-gpl-v2-are-not-incompatible/

An older discussion on the subject. There are many opinions and no conclusions,
though.
- http://diveintomark.org/archives/2008/03/07/iphone-gpl
- One of the more interesting opinions is one that tries to refute the "spirit
  of the license" argument (where it is argued that it is difficult or expensive
  for an app user to customize an app with a modified version of the software)
- The reasoning is this: "So if I write a piece of code that only compiles if
  you use a $2000 compiler suite [...] then it is the code itself not the tools
  I am obligated to supply. If anyone can buy a $99 developer license that is
  just part of the tool chain cost."

The actual licenses:
- http://www.gnu.org/licenses/gpl-2.0.txt
- http://www.gnu.org/licenses/gpl-3.0.txt
- http://www.gnu.org/copyleft/lesser.html

Articles about the LGPL and iPhone apps:
- This one believes it's possible, although it's not in the spirit of the
  license
  http://huyzing.com/2009/08/24/compatibility-between-the-iphone-app-store-and-the-lgpl/
- This one believes it's not possible because of the $99/year cost
  http://loufranco.com/blog/files/lgpl-and-the-iphone.html


Programming my own Go engine
----------------------------
Fuego is a so-called "Monte Carlo" engine, so that's what I am going to
research.
- A basic description what it's about: http://senseis.xmp.net/?MonteCarlo
- MCTS = Monte Carlo Tree Search
- "The principles of MCTS algorithms were published in the proceedings of the
  Computer and Games conference, which was held together with the Olympiad."
  (the ICGA Computer Olympiad, http://senseis.xmp.net/?ComputerOlympiad)
- UCT is a simple but effective form of MCTS, following link includes
  pseudo-code: http://senseis.xmp.net/?UCT
- RAVE seems to be another method of MCTS, but one that is a heuristic
  (refers to experience-based techniques for problem solving, learning, and
  discovery. Heuristic methods are used to speed up the process of finding a
  good enough solution, where an exhaustive search is impractical)
- MCTS publications: http://webdocs.cs.ualberta.ca/~mmueller/mcts.html
- Computer Go page: http://senseis.xmp.net/?ComputerGo

Research stopped for the moment because I haved decided to use Fuego.


GTP - Go Text Protocol
----------------------
The reference is here: http://www.lysator.liu.se/~gunnar/gtp/

Apparently there are two versions of GTP:
- GTP version 1: Although superseded by GTP version 2, this protocol version
  may still have some relevance because it is implemented by the ubiquitous
  GNU Go. Version 3.0.0 of GNU Go actually has the reference implementation of
  GTP version 1, which at the same time serves as the protocol specification
  since there is no other good documentation.
- GTP version 2: The current protocol version. The specification still has
  "draft" status, but since there have been no changes since 2002, it's pretty
  safe to assume that version 2 of the protocol is stable. In theory, GNU Go
  3.4 has the reference implementation of GTP version 2. Whether this is true
  in practice has still to be verified.

A simple GTP session might consist of the following commands:

  protocol_version
  name
  version
  boardsize 9
  clear_board
  showboard
  quit

With Fuego, this looks like this:

  protocol_version
  = 2

  name
  = Fuego

  version
  = 1.0

  boardsize 9
  =

  clear_board
  =

  showboard
  =
    A B C D E F G H J
  9 . . . . . . . . . 9
  8 . . . . . . . . . 8
  7 . . + . . . + . . 7
  6 . . . . . . . . . 6
  5 . . . . . . . . . 5
  4 . . . . . . . . . 4
  3 . . + . . . + . . 3
  2 . . . . . . . . . 2
  1 . . . . . . . . . 1  B to play
    A B C D E F G H J

  quit
  =

Fuego installs two executables:
- fuego (FuegoMain application): This is the GTP interface to GoUctPlayer, a
  Monte-Carlo tree search Go player.
- fuego_test (FuegoTest application): GTP interface to a GTP engine with test
  commands. The --player argument tells the application to use a player with
  the specified behaviour.

Attaching to a GTP interface involves the following steps:
- Launch the desired executable in the background
- Attach to the process' input and output streams
- Write to the input stream to give commands to the GTP engine
- Read from the input stream to get the GTP engine's answers
- Unfortunately, on iOS it is not possible to spawn a process in the background
  as it used to be possible with NSTask on Mac OS X
- For this reason, it is not possible to include the Fuego executable with the
  application, launch the program in the background and attach to its standard
  input and output streams
- Instead, I assume that all this needs to be "simulated" by spawning a thread


Fuego
-----
This section contains basic research about what services Fuego can provide.

A list of all GTP commands known by Fuego 1.0 (obtained with GTP command
"list_commands") follows. Those commands marked with an asterisk are described
in the GTP 2.0 specification.

all_move_values
autobook_additive_cover
autobook_close
autobook_counts
autobook_cover
autobook_expand
autobook_export
autobook_import
autobook_load_disabled_lines
autobook_mainline
autobook_merge
autobook_open
autobook_param
autobook_priority
autobook_refresh
autobook_save
autobook_scores
autobook_state_info
autobook_truncate_by_depth
boardsize (*)
book_add
book_clear
book_delete
book_info
book_load
book_moves
book_position
book_save
book_save_as
clear_board (*)
cputime
cputime_reset
echo
echo_err
final_score (*)
final_status_list (*)
fixed_handicap (*)
fuego-license
genmove (*)
get_komi
get_random_seed
gg-undo
go_board
go_clock
go_param
go_param_rules
go_param_timecontrol
go_player_board
go_point_info
go_point_numbers
go_rules
go_safe
go_safe_dame_static
go_safe_gfx
go_safe_winner
go_sentinel_file
go_set_info
gogui-analyze_commands
gogui-interrupt
gogui-play_sequence
gogui-setup
gogui-setup_player
is_legal
kgs-genmove_cleanup
kgs-time_settings
known_command (*)
komi (*)
list_commands (*)
list_stones
loadsgf (*)
name (*)
pid
place_free_handicap (*)
play (*)
protocol_version (*)
quiet
quit (*)
reg_genmove (*)
reg_genmove_toplay
savesgf
set_free_handicap (*)
set_random_seed
sg_compare_float
sg_compare_int
sg_debugger
sg_exec
sg_param
showboard (*)
time_lastmove
time_left (*)
time_settings (*)
uct_bounds
uct_default_policy
uct_estimator_stat
uct_gfx
uct_max_memory
uct_moves
uct_param_globalsearch
uct_param_player
uct_param_policy
uct_param_rootfilter
uct_param_search
uct_patterns
uct_policy_moves
uct_prior_knowledge
uct_rave_values
uct_root_filter
uct_savegames
uct_savetree
uct_score
uct_sequence
uct_stat_player
uct_stat_player_clear
uct_stat_policy
uct_stat_policy_clear
uct_stat_search
uct_stat_territory
uct_value
uct_value_black
undo (*)
version (*)

Working with .sgf files:
- The GTP commands "loadsgf" and "savesgf" are useful for this. The argument
  these commands take is a path to the .sgf file to save or load. Due to the
  limitations of the GTP protocol, the filename cannot include spaces, hash
  signs (#), or control characters.
- If coding is involved, the classes SgGameReader and SgGameWriter in the
  SmartGo library will be useful

Determine if stones are captured as the result of a move, and which stones:
- The GTP command "list_stones" enumerates the positions that the specified
  player has stones on. If compared with the current board situation in
  Little Go, any differences indicate which stones have been captured.
- Although the GTP specification does not recommend it, the result of GTP
  command "showboard" could also be used to find any differences with the
  current board situation in Little Go.
- Implementing this myself should also be not too hard: Code an algorithm that
  finds finds out how many liberties a stone or a group has, then examine the
  four neighbours of the stone that was just placed.

Scoring
- Possibly useful GTP commands: final_score (GoUctCommands::CmdFinalScore),
  final_status_list (GoUctCommands::CmdFinalStatusList),
  uct_score (GoUctCommands::CmdScore)

Two computer players:
- The "genmove" GTP command has an argument that allows to specify the color
  to generate a move for
- This can be leveraged to effectively let Fuego play against itself

Recommend a move
- The "reg_genmove" GTP command generates a move, but does not play it

Other useful stuff
- The "go_point_info" GTP command allows to query Fuego about various properties
  of the specified point. One of the properties is whether the point would be a
  legal move for either black or white
- The "is_legal" GTP command allows to query Fuego whether it would be legal for
  the specified player to play on the specified point


Details on Fuego's smartgame module
-----------------------------------
Classes
- SgNode represents a node in a tree structure
- SgProp represents a property of a node
- SgPoint represents a vertex on the board, but can also be used to refer to
  the "virtual" point of a pass move

Nodes and properties
- One node can have 0-n properties
- A property has a type (e.g. SG_PROP_MOVE)
  - The term that is used, though, is "ID" - a misnomer in my opinion.
  - SgPropID is the type used to store a property ID/type
  - SgProp::ID() is called to get at a property object's ID/type
- A property is additionally classified by (binary) flags that can be set or
  cleared on it
  - For instance, a property with ID SG_PROP_MOVE has set the flag
    SG_PROPCLASS_MOVE, and either SG_PROPCLASS_BLACK or SG_PROPCLASS_WHITE
    to indicate whether the move was made by the black or the white player
  - SgProp::Flag() returns a boolean value; the method is used to check whether
    a given flag is set on the property object

The node tree
- The terminology used by documentation and SgNode methods views the tree with
  the root node at the top, and the branches pointing downwards
- For instance
                                node0
                               /    \
                              /      \
                           node1     node2
                          /  |  \        \
                         /   |   \        \
                      node3 node4 node5   node6

- Looking at this example, and at the methods in SgNode, one can say that
  - node0->IsRoot() == true
  - node1->Father() == node0
  - node1->RightBrother() == node2
  - node1->LeftBrother() == NULL
  - node6->HasBrother() == false
  - node5->NumLeftBrothers() == 2
  - node1->NumSons() == 3
  - node1->LeftMostSon() == node3
  - node1->RightMostSon() == node5
  - SgNode::IsTerminal() == true for node3, node4, node5 and node6
  - SgNode::IsBranchPoint() == true for node0 and node1
  - SgNode::IsOnMain() == true for node0, node1 and node3

Code snippets:

void inspectProp(SgProp* prop)
{
  SgPropID propID = prop->ID();
  std::string propLabel = prop->Label();
  bool black = prop->Flag(SG_PROPCLASS_BLACK);
  bool white = prop->Flag(SG_PROPCLASS_WHITE);
  bool info = prop->Flag(SG_PROPCLASS_INFO);
  bool anno = prop->Flag(SG_PROPCLASS_ANNO);
  bool stat = prop->Flag(SG_PROPCLASS_STAT);
  bool move = prop->Flag(SG_PROPCLASS_MOVE);
  bool mark = prop->Flag(SG_PROPCLASS_MARK);
  NSLog(@"propID = %d, propLabel = %s, black = %d, white = %d, info = %d, anno = %d, stat = %d, move = %d, mark = %d",
        propID, propLabel.c_str(), black, white, info, anno, stat, move, mark);
}

void inspectNode(SgNode* node)
{
  bool hasFather = node->HasFather();
  bool isRoot = node->IsRoot();
  bool hasLeftFather = node->HasLeftBrother();
  bool hasRightBrother = node->HasRightBrother();
  bool hasSon = node->HasSon();
  bool hasBrother = node->HasBrother();
  bool isOnMain = node->IsOnMain();
  NSLog(@"hasFather = %d, isRoot = %d, hasLeftFather = %d, hasRightBrother = %d, hasSon = %d, hasBrother = %d, isOnMain = %d",
        hasFather, isRoot, hasLeftFather, hasRightBrother, hasSon, hasBrother, isOnMain);
  const SgPropList& propList = node->Props();
  SgPropListIterator propListIterator(propList);
  while (propListIterator)
  {
    SgProp* prop = *propListIterator;
    inspectProp(prop);
    ++propListIterator;
  }
}
