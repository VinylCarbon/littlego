Purpose of this document
------------------------
This document is the starting point for developers that want to familiarize
themselves with the Little Go project, i.e. developers that are new to the
project, and also me, after I come back to the project after several months
or years :-)


Folder structure
----------------
<root>
 +-- LICENSE           The Apache license file.
 +-- LICENSE.html      The Apache license in HTML format (for display on the
 |                     device).
 +-- NOTICE            Attribution notices.
 +-- 3rdparty          This folder does not exist in a pristine clone of the
 |                     Git repository. It is created when the 3rdparty software
 |                     packages required to run Little Go are downloaded and
 |                     built.
 +-- doc               This folder contains documents not relevant for building
 |                     the Little Go binary; some of these files are included
 |                     in the application bundle that is distributed on the
 |                     App Store.
 +-- doxygen           This folder contains a configuration file Doxyfile for
 |                     Doxygen; the folder is intended to receive the files
 |                     generated by Doxygen.
 +-- patch             This folder contains files used to patch 3rdparty
 |                     software before the build
 +-- resource          This folder contains the project's resources such as the
 |                     .xib files.
 +-- script            This folder contains command line scripts.
 +-- src               This folder contains the project's source code.
 +-- test              This folder contains the project's unit test files.


Document reference
------------------
Documents described here are located in the Documents folder.

README
  This document is the starting point for end users. It provides a quick
  overview of what Little Go is about, points to other interesting documents
  of the project, and also contains other important information that should be
  immediately accessible to new or recurring users.

TODO
  This document contains a list with not-so-important features (aka
  "good ideas" :-); the list is sorted by priority, which provides a rough
  indicator in what order the features should be implemented. Things listed
  in the Roadmap are much more important and should be implemented before
  things in TODO.

Roadmap
  This document contains a list with important features and the order in
  which they should be implemented. The purpose of this list is to avoid
  distraction by the "good ideas" listed in TODO, which may sometimes be more
  attractive to implement but are not this important.

ChangeLog
  This document should not duplicate SCM log messages. Its entries should be
  rather high-level so that it can be used as a source for release notes, e.g.
  to populate the "Changes in this release" section in the README document.
  Examples for things that should be included in the ChangeLog:
  - Fixes for distinct bugs, with or without a bug report in the bug tracker
  - New features, with or without a bug report in the bug tracker
  - Other "big" changes that are noticable by the users of the software
    (e.g. the program icon has changed)
  - Things that may not be noticable but that need to be brought to the
    attention of the users of the software (e.g. a license change)

ReleaseSteps
  This document lists the steps needed to make a project release.


Other files
-----------
Little Go.xcodeproj
  The Xcode project file. The format is "Xcode 3.1-compatible".

resource/Info.plist
  The information property list file that describes the Little Go application
  bundle.

script/get-and-build-3rdparty-software.sh
  Helper script for downloading and building all 3rdparty software packages that
  are required to build and run Little Go.


3rdparty software build
-----------------------
Before the first Xcode build of the project is possible, 3rdparty software must
be downloaded and built. Hopefully, the following convenience script does all
this for you if you run it on the command line from the project root folder
like this:

  ./script/get-and-build-3rdparty-software.sh

A short overview of what the script does:
- Invoke build-software.sh for each 3rdparty software package, in the correct
  order of dependencies
- build-software.sh first invokes build-env.sh to obtain general build settings;
  build-env.sh reflects the Xcode build environment such as base SDK, or
  deployment target. If the Xcode build environment changes, build-env.sh also
  needs to be modified
- build-software.sh then invokes the package-specific build script (e.g.
  build-fuego.sh) to obtain information specific to that package. Besides build
  settings this also includes the location where the package sources can be
  downloaded
- build-software.sh then proceeds with a number of fixed steps: download and
  extract the package sources, execute pre-build steps (e.g. apply patches,
  run "configure"), run the actual build (e.g. run "make"), execute post-build
  steps, and finally install the built software
- All this occurs within the project top-level folder "3rdparty", which is
  automatically created by the build scripts


Xcode build system configuration
--------------------------------
Important configuration settings in Xcode:
- HEADER_SEARCH_PATHS = ./3rdparty/install$(SDKROOT)/include
- LIBRARY_SEARCH_PATHS = ./3rdparty/install$(SDKROOT)/lib
- OTHER_LDFLAGS = -lfuego -lboost_system -lboost_thread -lboost_filesystem -lboost_program_options
  Note: If a future version of Fuego requires additional Boost libraries, they
  must be added here.
- GCC_PREPROCESSOR_DEFINITIONS = NDEBUG
  Note: This macro is required because the project links against a release
  build of Fuego.


Platform notes
--------------
- The Xcode project is prepared to build Little Go both for iOS and for the
  iPhone Simulator.
- The base SDK is "Latest iOS", which means that the project is set up with a
  moving target SDK. The latest release of the project was made with iOS 4.2.
- The deployment target is not set, which means that it defaults to the same
  version as the base SDK.


.xib design notes
-----------------
I find it difficult to remember some specialities about the UI design in the
various .xib files. The following notes are to .xib files what inline
documentation is to source code:
- MainWindow.xib instantiates the main controller object, which is an instance
  of TabBarController. The main controller in turn references and instantiates
  all child controllers. To see the class of each sub-controller, select the
  main controller object in the .xib file, then from the menu select
  View -> as Columns. Navigate to the child controller of your choice and
  display its properties in the Inspector window. The properties include the
  controller's class, and the name of the NIB file associated with the
  controller.
- Each TabBarItem in MainWindow.xib has a unique numeric value assigned to its
  "tag" property. A controller class that is responsible for managing several
  different tabs can query this "tag" property and thus perform different
  actions depending on which tab is currently selected. The tag values in the
  .xib must match the values of the enumeration TabType, which is defined in
  Constants.h.


UI elements design notes
------------------------
TableViewCell
- TableViewCellFactory creates a couple of table cell types that are not
  available from the UIKit
- For the cell type that has a slider, I did a bit off debugging/inspection of
  the default UITableViewCell and its subviews; following are the results
- Size of a UITableViewCell (from its frame rect) = 320x45
- In a cell with style UITableViewCellStyleValue1 and accessoryType
  UITableViewCellAccessoryNone
  - cell.contentView frame rect = 10/0, 300x43
  - cell.textLabel frame rect = 10/11, 161x21 (text is "Cross-hair distance")
  - cell.detailTextLabel frame rect = 280/11, 10x21 (text is "2")
- In a cell with style UITableViewCellStyleValue1 and accessoryType
  UITableViewCellAccessoryDisclosureIndicator
  - cell.contentView frame rect = 10/1, 280x43
  - cell.textLabel frame rect = 10/11, 46x21 (text is "Black")
  - cell.detailTextLabel frame rect = 163/11, 107x21 (text is "Human player")
  - the disclosure indicator button is a direct subview of the cell (i.e. it's
    not part of the content view, and it's not in the accessoryView) with
    frame rect = 280/1, 30x43


Architecture and implementation notes
-------------------------------------
- Error handling: TODO
- Memory management: Uses retain/release, there is no garbage collection on iOS.
- Communication with Fuego
  - How it normally works: On PC platforms this is done by running Fuego in a
    separate process and then attaching an output and an input stream to that
    process' stdin and stdout.
  - The problem: iOS does not allow to launch other processes, therefore a
    different solution is required
  - The solution: What works very nicely is to run the Fuego engine in a
    secondary thread and to let it attach its input/output streams to a pair of
    named pipes. The Fuego client also runs in a secondary thread and attaches
    two complementary streams to the same pair of named pipes. Synchronization
    between the two threads is achieved through the pipes' blocking behaviour.
- Thread architecture
  - Main thread: Reacts to user input; submits commands to the GTP client;
    is notified asynchronously by the GTP client after a command has been
    processed; updates the GUI with information obtained from the response to
    the command.
  - GTP client secondary thread: Reacts to commands submitted by the main
    thread; sends the commands to the GTP engine via file stream which is
    attached to a named pipe NP1; wakes up when it receives the response from
    the GTP engine via file stream which is attached to another named pipe NP2;
    notifies the main thread of the response.
  - GTP engine secondary thread: Reacts to commands received from the GTP
    client via file stream which is attached to named pipe NP1; processes the
    command, then sends the response back to the GTP client via file stream
    which is attached to a named pipe NP2.
  - Communication between main thread and GTP client secondary thread happens
    entirely within the GtpClient class; synchronization occurs with the help
    of the NSObject method performSelector:onThread:withObject:waitUntilDone:().
    When the response to the command is ready, GtpClient posts a notification
    to the global notification center. The notification is delivered in the
    main thread context, which allows arbitrary observers to react to the event
    without having to care about threading issues.
  - Communication between GTP client and GTP engine secondary threads is routed
    through named pipes; synchronization occurs via the file streams' blocking
    read behaviour.
  - Because of file streams' blocking reads, communication between GTP client
    and GTP engine is essentially synchronous. As a consequence, the main thread
    will be blocked if it wants to submit a command to the GTP client while the
    client is still waiting for the response to a previous command. For this
    reason, all GUI elements that trigger a GTP command should be disabled
    while a command is being processed.
- GTP command sequence: Even though responses for GTP commands are received
  asynchronously, the commands themselves are processed in the order that they
  are submitted. This means that any number of GTP commands can be submitted as
  fast as possible (i.e. without having to wait for the response), as long as
    1) The submitter does not need the result of the command
    2) A later command does not need the GTP engine to be in a particular state
- Application states and transitions
  - When the application starts up (application:didFinishLaunchingWithOptions:),
    it displays the "Play" view. If the application detects that a game was in
    progress the last time it was running, it loads that game so that the user
    may continue where he has left off. If no game-in-progress is detected, a
    new game is started.
  - When the application becomes suspended (applicationDidEnterBackground:), the
    current user preferences are saved, and the game in progress is written to
    a temporary .sgf file. This is to guard against a forceful shutdown either
    by the user or the system ("purge") while the application is suspended and
    helpless. Nothing special is done to keep the GTP engine running, or to
    shut it down - it is expected that the system simply suspends code
    execution at the appropriate time.
  - When the application is terminated (applicationWillTerminate:), it performs
    the same save operations as if it were being suspended.
  - When the application resumes (applicationWillEnterForeground:) it does
    nothing.
  - When the application becomes inactive (applicationWillResignActive:), it
    suppresses audio/vibration feedback so as not to disturb the user while the
    screen is locked (or an interruption is in progress). In addition, a
    computer vs. computer game is paused.
  - When the application becomes active (applicationDidBecomeActive:), it
    re-enables audio/vibration if these features were disabled due to becoming
    inactive. A paused computer vs. computer game is not automatically resumed,
    though, it must be explicitly resumed by user interaction.
- MVC design pattern considerations
  - GoGame is the master model for PlayView and PlayViewController. These
    classes implement the traditional MVC design pattern where the view
    (PlayView) is a direct observer of the model (GoGame).
  - I make a note of this because coming from Cocoa one might expect the Cocoa
    variation of MVC where model and view are completely separate and all
    communication goes through the controller. IMO this doesn't make sense here
    because iOS does not support Cocoa bindings. In other words, the system
    frameworks do not provide any pre-fabricated controllers, and I myself do
    not want to spend the time required to implement the overhead necessary for
    a complete separation of model and view. Re-usability is not a key design
    of this project.
- Preferences: The iOS Application Programming Guide says that "The Settings
  bundle is generally the preferred mechanism for displaying preferences", then
  goes into details about how to use such a Settings bundle. I don't like to
  separate the UI for application preferences from the application, though, and
  therefore chose to implement a dedicated Preferences view inside the
  application.
- The "Play" view is the most complex view of the entire application. It has
  a large number of UI elements that must somehow be fitted onto the small
  screeen estate available on the iPhone. This "crowded" environment requires a
  thoughtful UI design, which I try to outline here:
  - The game view
    - The game view has two main purposes: 1) To accurately represent the
      current game state, and 2) to provide user interaction so that the user
      can place a stone
    - Because the Go board is square, but iOS device screens are oblong, the
      game view cannot take full advantage of all the available screen estate.
      The game view is responsible for making the most of the current situation,
      dynamically adjusting to any changes such as device orientation changes.
    - User preferences modify view appearance (e.g. display labels) and user
      interaction behaviour.
  - The toolbar
    - Only the most important actions can be represented by items on the
      toolbar. The user usually wants to play a game, so toolbar items should
      represent actions that are related to game moves (e.g. "pass").
    - At the right-most position there is a "Game Actions" button which provides
      access to an action sheet with additional actions that do not fit on the
      toolbar. Only actions related to games as a whole are to be displayed on
      this action sheet.
    - When a computer vs. computer game starts, the usual game move actions
      (e.g. "pass") do not make sense and are therefore hidden. The toolbar
      instead displays buttons that can be used to control the automatic game
      play of the computer players (e.g. the game can be paused).
    - Most toolbar items do not use the iOS provided icons available from
      UIBarButtonItem. The reason is that, although the icons' visual appearance
      might seem appropriate, their semantic meaning is not!
  - The status line
    - Currently a status line is situated below the game view, which is used
      to display information about the current game state to the user
    - Somehow this seems to be rather clunky, I want to find a different way
      how to represent the information in the UI
  - The activity indicator
    - An activity indicator is needed to let the user know when the Go engine
      is busy so that he knows why some UI elements are disabled
    - Currently the indicator is located in the toolbar, this might change in
      a future version.


Coding guidelines
-----------------
- Class names start with an uppercase letter
- Method names start with a lowercase letter
- Member variables use the the prefix "m_" to distinguish them from variables
  that are local to a method
- Spaces, no tabs
- 2 spaces per indentation level
- Opening/closing braces are placed on their own line
- No space is used to separate opening/closing paranthesis from the expression
  they surround
- Operators (e.g. "+" in string concatenations) are separated by spaces from
  their operands
- Lines should not be longer than 80 characters; for comment lines this limit
  is much stricter than for lines of code
- Setter/getter methods should be named after the property they encapsulate
  (e.g. getter = icon(), setter = setIcon:())
- Private methods of a class are declared in class extension which is declared
  in the .m file
- Everything should be documented with Doxygen documentation blocks


Unit tests
----------
All unit test related files are located in the top-level folder "test".

The Xcode project defines a target "Unit tests" which builds a unit test bundle,
then immediately runs the tests in its "Run Script" phase. The main target
depends on the "Unit test" target to make sure that tests are built and executed
automatically if a piece of source code that is under test has changed.

Notes about the "Unit test" target:
- All tests in this target are what Apple calls "logic tests" (see [1]), i.e.
  unit tests exercise more or less isolated classes. The test source code is
  built using the iOS Simulator SDK, but the tests are run outside of the
  simulator as part of the build process.
- All source code files that are unit tested must be added to the "Unit test"
  target so that they are built for that target.
- The build setting "Header Search Path" is set to the value "./src". Since the
  test sources are completely separated from the normal application sources, I
  don't want to deal with relative path issues for each #import statement. The
  application can be seen as third party software from the point of view of the
  unit test bundle.
- Because application source files depend on the presence of a prefix header,
  the "Unit test" target has to have the same "Prefix header" build settings
  as the main application target.
- Compiling ApplicationDelegate for the "Unit test" target pulls in Fuego/Boost
  (via GTP classes) as dependencies. As a consequence, the "Unit test" target
  must be set up with Header/Library search paths that are the same as in the
  main application target.
  - Additionally, the build setting "Symbols hidden by default" must be set to
    YES to prevent build warnings because of symbol visibility differences
    between Fuego/Boost libraries and the unit test bundle. For some unknown
    reason, this build setting is correct by default in the main application
    target, but incorrect in the "Unit test" target.

[1] http://developer.apple.com/library/ios/#documentation/Xcode/Conceptual/iphone_development/135-Unit_Testing_Applications/unit_testing_applications.html


Source code documentation with Doxygen
--------------------------------------
There is a "doxygen" target that can be used to transform the source code
documentation into a set of HTML files. The target uses a shell script that
assumes that Doxygen is installed in

  /sw/bin

This is the standard path for the "fink" project. If you have doxygen installed
somewhere else (e.g. /usr/local/bin) you need to change the target's shell
script.

The Doxygen configuration file is located in

  doxygen/Doxyfile

Notes about the configuration:
- Doxygen recursively searches for *.h, *.m and *.mm files in the project
  top-level folder "src".
- Private methods declared in class extensions or categories in the .m files
  are not included in the documentation process. Change this by setting
  EXTRACT_LOCAL_METHODS = YES inside Doxyfile.
- It is assumed that the command line tool "dot" is available and installed in
    /sw/bin
  dot is part of the Graphviz package and is used to generate a couple of
  diagram types (e.g. class diagrams, collaboration diagrams).


iOS topics covered in this project
----------------------------------
Little Go uses declared properties, some of them generated, others added
manually. Although declared properties are a language feature introduced to
Objective-C quite some time ago, this is still a new topic for me, which is why
I mention it here. Details can be found in [1].

The Fuego engine runs in a secondary thread, and communication with the engine
also occurs within a secondary thread. Basic understanding of how threading and
run loops work can be found in [2]. Scheduling with NSTimer is covered by [3].

Little Go is quite configurable and has a preference tab to manage all the
settings. This requires the "User Defaults" system (see [4]).

[5] explains the nib object lifecycle. This information is helpful for proper
cleanup during application shutdown. This document also contains information
on how to obtain references to resources embedded in the application bundle
(e.g. sound or image files).

Rendering a Go board in a UIView involves drawing with the Core Graphics and
UIKit frameworks. An introduction to drawing is provided by [6], more specific
information about drawing with Quartz is in [7].

User input is managed by the iOS event handling system. [8] describes how events
and touches are processed by the system on a fundamental level, and how, on a
higher level, gesture recognizer classes help with reacting to specific types
of user input.

[9] and [10] go into detail about the different types of views and view
controllers, and how they can be combined to make a nice and efficient UI. Worth
mentioning are the two sections of special interest that cover animations and
modal view controllers. Table views are such an important topic that an entire
guide [11] has been written about them. Last but not least, [12] provides a
useful all-in-one-page overview of the UI elements and styles available in iOS.

Observing various model objects for user preferences changes can be elegantly
solved using the Key-Value Observing (KVO) technique, which in turn is based on
Key-Value Coding (KVC). The two concepts are extensively documented in [13] and
[14].

Playing short sounds and vibrating the iOS device are covered by [15], while
[16] has additional in-depth information on Audio processing. Playing a system
sound requires the use of Core Foundation data types; getting values from iOS
or Cocoa data types across the boundary into Core Foundation is sometimes as
simple as casting from one type to the other. [17] has details about this
so-called system of "Toll-Free Bridged Types".

[18] is a very good starting point for solutions to rather high-level problems.
Handling documents (including the sync to iTunes) is thoroughly explained in
the subsecion "Files and the File System".

Tasks that should run while the app is in the background are also explained in
[18], in section "Executing Code in the Background". To understand blocks,
which are required for background tasks, a side-trip to [19] and [20] should be
sufficient.


[1]  iOS Reference Library > Guides > The Objective-C Programming Language > Declared Properties
[2]  iOS Reference Library > Guides > Threading Programming Guide
[3]  iOS Reference Library > Guides > Timer Programming Topics
[4]  iOS Reference Library > Guides > User Defaults Programming Topics
[5]  iOS Reference Library > Guides > Resource Programming Guide
[6]  iOS Reference Library > Guides > Drawing and Printing Guide for iOS
[7]  iOS Reference Library > Guides > Quartz 2D Programming Guide
[8]  iOS Reference Library > Guides > Event Handling Guide for iOS
[9]  iOS Reference Library > Guides > View Programming Guide for iOS
[10] iOS Reference Library > Guides > View Controller Programming Guide for iOS
[11] iOS Reference Library > Guides > Table View Programming Guide for iOS
[12] iOS Reference Library > Guides > iOS Human Interface Guidelines > iOS UI Element Usage Guidelines
[13] iOS Reference Library > Guides > Key-Value Observing Programming Guide
[14] iOS Reference Library > Guides > Key-Value Coding Programming Guide
[15] iOS Reference Library > Reference > System Sound Services Reference
[16] iOS Reference Library > Guides > Multimedia Programming Guide
[17] http://developer.apple.com/library/mac/#documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html
[18] iOS Reference Library > Guides > iOS Application Programming Guide
[19] iOS Reference Library > Getting Started > A Short Practical Guide to Blocks
[20] iOS Reference Library > Guides > Blocks Programming Topics


Compilation command
-------------------
The following lines represent the command to compile a single .cpp file in
Debug configuration for the iPhoneSimulator platform. Every line contains one
compiler switch or command-line argument.

/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin/gcc-4.2
-x c++
-arch i386
-fmessage-length=0
-pipe
-Wno-trigraphs
-fpascal-strings
-fasm-blocks
-O0
-Wreturn-type
-Wunused-variable
-DNDEBUG
-isysroot /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator4.2.sdk
-fexceptions
-fvisibility=hidden
-fvisibility-inlines-hidden
-mmacosx-version-min=10.6
-gdwarf-2
-D__IPHONE_OS_VERSION_MIN_REQUIRED=40200
-iquote "/Users/patrick/Documents/dev/littlego/build/Little Go.build/Debug-iphonesimulator/Little Go.build/Little Go-generated-files.hmap"
"-I/Users/patrick/Documents/dev/littlego/build/Little Go.build/Debug-iphonesimulator/Little Go.build/Little Go-own-target-headers.hmap"
"-I/Users/patrick/Documents/dev/littlego/build/Little Go.build/Debug-iphonesimulator/Little Go.build/Little Go-all-target-headers.hmap"
-iquote "/Users/patrick/Documents/dev/littlego/build/Little Go.build/Debug-iphonesimulator/Little Go.build/Little Go-project-headers.hmap"
-F/Users/patrick/Documents/dev/littlego/build/Debug-iphonesimulator
-I/Users/patrick/Documents/dev/littlego/build/Debug-iphonesimulator/include
-I3rdparty/install/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator4.2.sdk/include
"-I/Users/patrick/Documents/dev/littlego/build/Little Go.build/Debug-iphonesimulator/Little Go.build/DerivedSources/i386"
"-I/Users/patrick/Documents/dev/littlego/build/Little Go.build/Debug-iphonesimulator/Little Go.build/DerivedSources"
-include /var/folders/K+/K+NmKFX-FA4IgmDBY9aGdk+++TM/-Caches-/com.apple.Xcode.502/SharedPrecompiledHeaders/Little_Go_Prefix-gatqaltedfwqgcbkvwvyfnixuhqh/Little_Go_Prefix.pch
-c /Users/patrick/Documents/dev/littlego/src/MyClass.cpp
-o "/Users/patrick/Documents/dev/littlego/build/Little Go.build/Debug-iphonesimulator/Little Go.build/Objects-normal/i386/MyClass.o"

Discussion of options not used in 3rdparty builds:
-x c++
  The language of the source file. No need to set this, so far I am happy with
  the default language selection of the compiler.
-fmessage-length=0
  Error messages are not line-wrapped. No need to set this, has no influence on
  the code produced.
-Wno-trigraphs
  A warning. No need to set this, has no influence on the code produced.
-fpascal-strings
  APPLE ONLY. Allow Pascal-style string literals. No need to set this, this is
  arcane and as far as I'm concerned have no influence on the code produced.
-fasm-blocks
  APPLE ONLY. Allow assembly code within a C/C++ file. No need to set this,
  this is arcane and as far as I'm concerned have no influence on the code
  produced.
-O0
  Optimization. This is set differently for 3rdparty libraries by design.
-Wreturn-type
  A warning. No need to set this, has no influence on the code produced.
-Wunused-variable
  A warning. No need to set this, has no influence on the code produced.
-fexceptions
  Enable exception handling. No need to set this, is already enabled by default
  for languages like C++ that support exceptions.
-mmacosx-version-min=10.6
  Same as MACOSX_DEPLOYMENT_TARGET.
-D__IPHONE_OS_VERSION_MIN_REQUIRED=40200
  No need to set this, iOS target version for 3rdparty libraries is defined
  via IPHONE_DEPLOYMENT_TARGET.
-iquote /some/include/path
  Specifies that this include path is searched for includes that were specified
  with quotes, but not for those specified with angle brackets (<>). No need to
  set this, has no influence on the code produced.


Boost build/installation issues
-------------------------------
No issues, build works out of the box.


Fuego build/installation issues
-------------------------------
Build
- The build script needs to specify the configure flag --with-boost-libdir,
  otherwise configure aborts with a linker error.

Installation
- "make install" only copies the executables (fuego, fuego_test), but not the
  libraries nor the headers. The build script for Fuego applies a patch that
  modifies a number of Makefile.am files. The changes made are to rename the
  "noinst_LIBRARIES" property to "lib_LIBRARIES", and to rename the
  "noinst_HEADERS" property to "pkginclude_HEADERS". Notes:
  - Libraries are installed under
      <prefix>/lib
  - Headers are installed under
      <prefix>/include/fuego
    because "pkginclude" is used instead of "include"
  - I would have preferred to keep sub-folders, e.g.
      <prefix>/include/fuego/gtpengine
    In theory, to make this work it should be possible to use
    "nobase_pkginclude_HEADERS". In practice, however, this does not work, the
    "nobase" prefix has no effect. The reason for this is unknown. I have tried
    the following combinations, but could not get it to work as desired:
      pkginclude_HEADERS     -> installs into include/fuego/*
      nobase_include_HEADERS -> installs into include/*
      nobase_dist_HEADERS    -> installs into include/*
- In addition, the build script creates and installs a single unified library
  that contains all the object files within Fuego's separate library files.


Changes to the Fuego source code
--------------------------------
1) FuegoUtil::FuegoMain()
- Create a new function FuegoUtil::FuegoMain(int argc, char** argv) in
  FuegoUtil.cpp and FuegoUtil.h
- Move the implementation in main(int argc, char** argv) from FuegoMain.cpp to
  this new function in FuegoUtil.cpp
- Also move the other support functions from FuegoMain.cpp to FuegoUtil.cpp
- Invoke FuegoUtil::FuegoMain() from main()

2) Add 2 new command line options "--input-pipe /path/to/pipe" and
   "--output-pipe /path/to/pipe"
- Basic option support requires modification to ParseOptions() and introduction
  of two new global variables
- Actual usage of the specified pipes requires modification to FuegoMain().
- Additional option support to check for mutually exclusive options
  (--input-file and --input-pipe) requires addition of a new function
  MutuallyExclusiveOptions() which is invoked from ParseOptions()

3) Remove usage of exit() in Help()
- ParseOptions() must be modified to return a value that indicates to its
  caller (FuegoMain()) whether the program should continue running or whether
  it should be terminated

4) Add 2 new GTP commands "list_moves" and "list_handicap"
- These commands are used to discover the move history and the list of handicap
  stones after Fuego has been instructed over GTP to load an .sgf file (with
  the "loadsgf" GTP command)
- This change allows Little to fully delegate all .sgf file handling to Fuego


Fuego Patches
-------------
The changes to the Fuego build system (Makefile.am files) and source code
are captured in a series of patch files that are stored in the top-level folder
"patch". The patches must be applied incrementally, in the order indicated by
the patch file name. Each file name starts with a numerical prefix to make the
order explicit.

Patches are automatically applied during the 3rdparty software build (cf.
section "3rdparty software build" in this file).

Patches are created like this:
  diff -ruN fuego-1.0-original fuego-1.0-new >fuego.patch

Patches are applied like this:
  cd fuego-1.0
  patch -p1 <fuego.patch


GTP engine settings
-------------------
The application's UI exposes a few GTP engine settings to the user (see the
GtpEngineSettings class for details). Conceptually the settings are attached to
the Player class, thus defining the playing strength/behaviour of a computer
player.

One could argue that this design is wrong: Since we have only one GTP engine,
the settings should be attached to GtpEngine. The point is valid, and the design
error is exposed when we have a game with two computer players (which player's
settings should be used to configure the GTP engine?). However, at the time
being the concept of defining a computer player's strength via its GTP engine
settings is simply too neat to abandon it.

Settings are applied to the GTP engine only when a new game is started. The
reason for this is mainly laziness - if we do it this way we don't have to
think about the consequences of changing fundamental parameters in mid-game.

In a computer vs. computer game, where we have two computer players with
potentially different settings, the black player's settings take precedence.
Choosing black is arbitrary, white could take precedence just as well.

Notes about default values
- fuegoMaxMemory = 64
  - I own an iPhone 3GS, and a 1st generation iPad, according to [2] both of
    them have 256 MB RAM
  - Tests on my iPhone 3GS have shown that 128 MB is too much - the app very
    quickly gets memory warnings and then is killed by the system
  - 64 MB however, seems to be an acceptable value - I have run an entire
    computer vs. computer game with that setting without any problems.
- fuegoThreadCount = 1
  - [1] recommends to set this to the number of cores
  - According to [2], the iOS devices I own only have one core
  - The upcoming A5 processor will have 2 cores [3]
- fuegoPondering = true
  - [1] recommends this for best performance
- fuegoReuseSubtree = true
  - [1] recommends this for best performance


[1] http://sourceforge.net/apps/trac/fuego/wiki/FAQ1
[3] http://en.wikipedia.org/wiki/List_of_iOS_devices
[3] http://en.wikipedia.org/wiki/Apple_A5


Notes on media files
--------------------
I have no artistic fibre in me, and I am just terrible at being creative and
producing any kind of media files. Therefore I like to keep an account of how I
got the stuff into the shape it is now, just in case I need to make changes in
the future.

wood-on-wood-12.aiff:
- Record various wood-on-wood sounds with an iPhone. Obviously the environment
  has to be sufficiently quiet to get a clean recording - 2am should be about
  the right time for doing this, after all the noisy neighbours have gone to
  bed :-) As there is still a bit of ambient noise, the recording should contain
  a few seconds of only noise. This will help later on during sound editing.
- Sync with iTunes, then convert the recordings to .aiff (also in iTunes).
- Start editing the sound files with Audacity. The first thing to do is to
  listen to all the recordings and select one with an effect that sounds nice
  and crisp.
- Sound editing consists of two steps only: Noise removal, and trimming to the
  correct level. Noise removal first requires that a stretch of the recording
  is selected that consists of only noise. Next select the "Noise Removal" tool
  (found in the Audacity's "Effects" menu) and click the "Get Noise Profile"
  button. After the dialog has closed, select the entire recording then reopen
  the tool a second time. The values should now be correctly adjusted to the
  noise level in the recording, so that you can simply click the "OK" button.
  After the tool has applied its effect, you can playback the recording to
  confirm that the noise has really been eliminiated.
- Select the portion of the recording that you want to use as the media file.
  Select "File > Export Selection", in the following dialog click the "Clear"
  button to remove the metadata stored by the iPhone in the recording, then
  save under "AIFF (Apple) signed 16 bit PCM". This is one of the few formats
  that the System Sound Services function AudioServicesPlaySystemSound() is
  capable of playing.


Working with .sgf files
-----------------------
The GTP commands "loadsgf" and "savesgf" are used to tell the GTP engine that it
should load or save a game from/to a specified filename. Unfortunately, due to
limitations of the GTP protocol not just any path/filename can be specified.
Notably, the path/filename may not contain spaces, hash signs (#) or control
characters.

The workaround here is to let the GTP engine load from/save to a temporary
file that is in a well-known location and whose filename/path does not violate
any of the GTP protocol restrictions. The application performs the necessary
pre-/post-processing via the NSFileManager API, which has none of the GTP
protocol limitations.

NSFileManager pre-/post-processing:
- Load game: Copy the real .sgf file to the well-known temporary file, from
  where it can then be loaded using the "loadsgf" GTP command. After the game
  has been loaded, the temporary file is removed.
- Save game: The "savesgf" GTP command is used to save the game to the
  well-known temporary file. After the game has been saved, the temporary file
  is moved to its real location.

This approach allows to keep the .sgf files in the application's documents
folder (which may contain spaces in its path), where they need to be located
for iTunes's syncing to work. It also allows to use arbitrary characters in the
filename, including unicode characters which might otherwise be interpreted as
control characters when sent over the GTP protocol wire.

Experiment has shown that the application's document folder is at the following
path locations:
- iOS Simulator environment
  /Users/<username>/Library/Application Support/iPhone Simulator/4.2/Applications/03C363CC-7330-40A0-A382-74FEA08E6C29/Documents
- iPhone device
  /var/mobile/Applications/FD1CCC4F-ECD3-43D8-87B9-359A4CCBFA87/Documents

Design note for code that needs to work with files
- The code should never assume that the current working directory is set to a
  specific location
- The code should not change the current working directory, unless absolutely
  necessary; working with absolute paths often obviates this need
- If the current working directory must indeed be changed, it should be changed
  back to the original location after the desired purpose has been achieved
