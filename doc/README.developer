Purpose of this document
------------------------
This document is the starting point for developers that want to familiarize
themselves with the Little Go project, i.e. developers that are new to the
project, and also me, after I come back to the project after several months
or years :-)


Quick-start guide on how to build and run Little Go
---------------------------------------------------
1. Unpack the source tar ball or clone the Git repository (since you are
   reading this document you probably have done this already)
2. Install Xcode 4 if you haven't done so already. With Xcode 4 the build should
   work out of the box, earlier or later Xcode versions probably require some
   tinkering.
3. Edit script/build-env.sh to match your development environment. Most
   important are the "Base SDK" variables which must refer to an iOS SDK that
   you have installed on your development machine. Usually, the version of Xcode
   that you have installed also determines which iOS SDK version is installed,
   so refer to the Xcode release notes or have a look at the contents of the
   folder /Developer/Platforms/iPhoneOS.platform/Developer/SDKs.
4. Launch Terminal.app and execute these commands:
     cd /path/to/littlego
     ./script/get-and-build-3rdparty-software.sh
5. Wait until the script has downloaded and built all 3rdparty software packages
   (see the section "3rdparty software build" further down for more details).
   This will take substantial time, for instance my 2.33 GHz Core 2 Duo laptop
   requires nearly one hour for building everything.
6. Launch Xcode by opening "Little Go.xcodeproj"
7. Change iOS Base SDK and deployment target versions to match your development
   environment
8. Check whether the reference to book.dat in the "resource" folder is valid.
   If it isn't (e.g. the reference appears in red color), fix the reference.
   The usual cause is that the reference points to a path that includes an SDK
   version that is different from the SDK version you used to build the 3rdparty
   software packages.
9. Make sure that you have a scheme that configures the target "Little Go" to
   use the build configuration "Debug". See "Xcode schemes" further down if you
   need more information.
10. Select that scheme, and one of the iPhone or iPad simulator destinations,
    from the toolbar's scheme selector
11. From the menu select Product > Run. The app should now be built in Debug
    mode and launched inside the simulator.


Folder structure
----------------
<root>
 +-- LICENSE           The Apache license file.
 +-- LICENSE.html      The Apache license in HTML format (for display on the
 |                     device).
 +-- NOTICE            Attribution notices.
 +-- README.mediawiki  Introduction to the project. This file is formatted in
 |                     Mediawiki markup and rendered as the front page on GitHub.
 +-- 3rdparty          This folder does not exist in a pristine clone of the
 |                     Git repository. It is created when the 3rdparty software
 |                     packages required to run Little Go are downloaded and
 |                     built.
 +-- doc               This folder contains documents not relevant for building
 |                     the Little Go binary; some of these files are included
 |                     in the application bundle that is distributed on the
 |                     App Store.
 +-- doxygen           This folder contains a configuration file Doxyfile for
 |                     Doxygen; the folder is intended to receive the files
 |                     generated by Doxygen.
 +-- patch             This folder contains files used to patch 3rdparty
 |                     software before the build
 +-- resource          This folder contains the project's resources such as the
 |                     .xib files.
 +-- script            This folder contains command line scripts.
 +-- src               This folder contains the project's source code.
 +-- test              This folder contains the project's unit test files.


Document reference
------------------
Documents described here are located in the Documents folder.

Roadmap
  This document contains a list with important features and the order in
  which they should be implemented. The purpose of this list is to avoid
  distraction by "good ideas" that may may sometimes be more attractive to
  implement but are not this important.

ChangeLog
  This document should not duplicate SCM log messages. Its entries should be
  rather high-level so that it can be used as a source for release notes, e.g.
  to populate the "Changes in this release" section in the README document.
  Examples for things that should be included in the ChangeLog:
  - Fixes for distinct bugs, with or without a bug report in the bug tracker
  - New features, with or without a bug report in the bug tracker
  - Other "big" changes that are noticable by the users of the software
    (e.g. the program icon has changed)
  - Things that may not be noticable but that need to be brought to the
    attention of the users of the software (e.g. a license change)

ReleaseSteps
  This document lists the steps needed to make a project release.

MANUAL
  This document contains a complete documentation of the application's end user
  functionality in prose. The file is parsed and displayed in game under the
  "Help" tab. For this to work, the content of this file must follow certain
  guidelines that are documented in DocumentGenerator.h.


Other files
-----------
Little Go.xcodeproj
  The Xcode project file. The format is "Xcode 3.2-compatible".

resource/plist/Info.plist
  The information property list file that describes the Little Go application
  bundle.

script/get-and-build-3rdparty-software.sh
  Helper script for downloading and building all 3rdparty software packages that
  are required to build and run Little Go.


3rdparty software build
-----------------------
Before the first Xcode build of the project is possible, 3rdparty software must
be downloaded and built. Hopefully, the following convenience script does all
this for you if you run it on the command line from the project root folder
like this:

  ./script/get-and-build-3rdparty-software.sh

A short overview of what the script does:
- Invoke build-software.sh for each 3rdparty software package, in the correct
  order of dependencies
- build-software.sh first invokes build-env.sh to obtain general build settings;
  build-env.sh reflects the Xcode build environment such as base SDK, or
  deployment target. If the Xcode build environment changes, build-env.sh also
  needs to be modified
- build-software.sh then invokes the package-specific build script (e.g.
  build-fuego.sh) to obtain information specific to that package. Besides build
  settings this also includes the location where the package sources can be
  downloaded
- build-software.sh then proceeds with a number of fixed steps: download and
  extract the package sources, execute pre-build steps (e.g. apply patches,
  run "configure"), run the actual build (e.g. run "make"), execute post-build
  steps, and finally install the built software
- All this occurs within the project top-level folder "3rdparty", which is
  automatically created by the build scripts


Xcode build system configuration
--------------------------------
Important configuration settings in Xcode (both for the "Little Go" and the
"Unit tests" targets):
- IPHONEOS_DEPLOYMENT_TARGET = 4.3
- ARCHS = armv7
  - The original value is $(ARCHS_STANDARD_32_BIT)
  - Xcode 4.5 resolves this to "armv7 armv7s", but the 3rd party software build
    currently does not support armv7s
  - armv7s therefore needs to be removed, otherwise a linker error occurs
  - An interesting article with background information, and also with some
    reassurance why we don't need armv7s at the moment, can be found here:
    http://www.galloway.me.uk/2012/09/hacking-up-an-armv7s-library/
- HEADER_SEARCH_PATHS = ./3rdparty/install$(SDKROOT)/include
- LIBRARY_SEARCH_PATHS = ./3rdparty/install$(SDKROOT)/lib
- OTHER_LDFLAGS = -lfuego -lboost_system -lboost_thread -lboost_filesystem -lboost_program_options -lCocoaLumberjack -ltouchzipkit -ObjC
  - Note 1: The option "-ObjC" is required by ZipKit and QuincyKit (actually
    QuincyKit specifies -all_load, but -ObjC is sufficient). Without this option
    ZipKit crashes the app when a ZKFileArchive object is created due to an
    unrecognized selector being sent to the object. For understanding the issue,
    read this technote: http://developer.apple.com/library/mac/#qa/qa1490/_index.html.
  - Note 2: If a future version of Fuego requires additional Boost libraries,
    they must be added here.
- libz.dylib has been added to the "Build Phases" section "Link Binary with
  Libraries". This is required to satisfy the dependencies of ZipKit and
  QuincyKit.
- GCC_PREPROCESSOR_DEFINITIONS = NDEBUG,LITTLEGO_NDEBUG (Release and Distribute_* configurations)
  GCC_PREPROCESSOR_DEFINITIONS = NDEBUG                 (Debug configuration)
  Note: The NDEBUG macro is required even for a debug build because the project
  links against a release build of Fuego. Because of this NDEBUG becomes useless
  for distinguishing between debug/release builds, so we need our own project
  specific macro, in this case named LITTLEGO_NDEBUG.
- The build configurations "Distribute_AdHoc" and "Distribute_AppStore" are
  duplicates of the "Release" build configuration, with the single exception of
  the code-signing identity (found in the "Code Signing" section). Whenever a
  change is made to one of the three configurations, the other two
  configurations must be kept in sync!


Xcode schemes
-------------
Xcode build schemes are not part of the Little Go distribution, nor are they
committed to the project's version control system. The following is a short
overview of how I usually configure my schemes:
- Let Xcode autocreate schemes. This results in one scheme for each of the
  project's targets.
- Rename the "Little Go" scheme to "Little Go Debug", and disable the "Archive"
  command. Also make sure that all actions except "Profile" use the "Debug"
  build configuration
- Duplicate "Little Go Debug", naming the new scheme "Little Go Release". Leave
  the "Archive" action disabled. Change all actions to use the "Release" build
  configuration
- Duplicate "Little Go Debug", naming the new scheme "Little Go AdHoc
  Distribution". Enable the "Archive" command. Change all actions to use the
  "Distribute_AdHoc" build configuration.
- Ditto, but name the new scheme "Little Go AppStore Distribution" and let the
  actions use the "Distribute_AppStore" build configuration
- In all schemes, make sure that the checkox "Run" is checked not only for the
  main target, but for the unit test target as well. This ensures that unit
  tests are build & run every time the main target is built. Note that the same
  result can also be achieved by a target dependency, which is saved to the
  Xcode project file and thus placed under version control.


Platform notes
--------------
- The Xcode project is prepared to build Little Go both for iOS and for the
  iPhone Simulator.
- The base SDK is "Latest iOS", which means that the project is set up with a
  moving target SDK. The latest release of the project was made with iOS 5.1.
- The deployment target is set to 4.3 so that the application keeps running on
  iOS 4 devices.


Upgrading the iOS SDK
---------------------
A few rough notes on what needs to be done when a new iOS SDK is installed on
the development machine:
- Delete (or backup) the 3rdparty folder
- Edit script/build-env.sh: Update the "Base SDK" variables to refer to the new
  SDK version that was just installed
- In Terminal.app, run script/get-and-build-3rdparty-software.sh to perform a
  full rebuild of all 3rdparty software packages
- If you haven't restarted Xcode, it might be a good idea to do so now
- In the Xcode project, update the reference to book.dat in the "resource"
  folder
- In the Xcode project, rebuild the "Little Go" target


.xib design notes
-----------------
I find it difficult to remember some specialities about the UI design in the
various .xib files. The following notes are to .xib files what inline
documentation is to source code:
- MainWindow.xib instantiates the main controller object, which is an instance
  of TabBarController. The main controller in turn references and instantiates
  all child controllers. To see the class of each sub-controller, select the
  main controller object in the .xib file, then from the menu select
  View -> as Columns. Navigate to the child controller of your choice and
  display its properties in the Inspector window. The properties include the
  controller's class, and the name of the NIB file associated with the
  controller.
- Each TabBarItem in MainWindow.xib has a unique numeric value assigned to its
  "tag" property. A controller class that is responsible for managing several
  different tabs can query this "tag" property and thus perform different
  actions depending on which tab is currently selected. The tag values in the
  .xib must match the values of the enumeration TabType, which is defined in
  Constants.h.


Info.plist notes
----------------
- See section "The version number"
- See section "Application icons"
- See section "Launch images"


UI elements design notes
------------------------
TableViewCell
- TableViewCellFactory creates a couple of table cell types that are not
  available from the UIKit
- For the cell type that has a slider, I did a bit off debugging/inspection of
  the default UITableViewCell and its subviews; following are the results
- Size of a UITableViewCell (from its frame rect) = 320x45
- In a cell with style UITableViewCellStyleValue1 and accessoryType
  UITableViewCellAccessoryNone
  - cell.contentView frame rect = 10/0, 300x43
  - cell.textLabel frame rect = 10/11, 161x21 (text is "Cross-hair distance")
  - cell.detailTextLabel frame rect = 280/11, 10x21 (text is "2")
- In a cell with style UITableViewCellStyleValue1 and accessoryType
  UITableViewCellAccessoryDisclosureIndicator
  - cell.contentView frame rect = 10/1, 280x43
  - cell.textLabel frame rect = 10/11, 46x21 (text is "Black")
  - cell.detailTextLabel frame rect = 163/11, 107x21 (text is "Human player")
  - the disclosure indicator button is a direct subview of the cell (i.e. it's
    not part of the content view, and it's not in the accessoryView) with
    frame rect = 280/1, 30x43


Architecture and implementation notes
-------------------------------------
- Memory management: Manual reference counting using retain/release, i.e. no
  ARC.
- Communication with Fuego
  - How it normally works: On PC platforms this is done by running Fuego in a
    separate process and then attaching an output and an input stream to that
    process' stdin and stdout.
  - The problem: iOS does not allow to launch other processes, therefore a
    different solution is required
  - The solution: What works very nicely is to run the Fuego engine in a
    secondary thread and to let it attach its input/output streams to a pair of
    named pipes. The Fuego client also runs in a secondary thread and attaches
    two complementary streams to the same pair of named pipes. Synchronization
    between the two threads is achieved through the pipes' blocking behaviour.
  - Fuego had to be patched to make this happen. For details, read the section
    "Changes to the Fuego source code".
- Thread architecture
  - Main thread: Reacts to user input; submits commands to the GTP client;
    is notified asynchronously by the GTP client after a command has been
    processed; updates the GUI with information obtained from the response to
    the command.
  - GTP client secondary thread: Reacts to commands submitted by the main
    thread; sends the commands to the GTP engine via file stream which is
    attached to a named pipe NP1; wakes up when it receives the response from
    the GTP engine via file stream which is attached to another named pipe NP2;
    notifies the main thread of the response.
  - GTP engine secondary thread: Reacts to commands received from the GTP
    client via file stream which is attached to named pipe NP1; processes the
    command, then sends the response back to the GTP client via file stream
    which is attached to a named pipe NP2.
  - Communication between main thread and GTP client secondary thread happens
    entirely within the GtpClient class; synchronization occurs with the help
    of the NSObject method performSelector:onThread:withObject:waitUntilDone:().
  - Communication between GTP client and GTP engine secondary threads is routed
    through named pipes; synchronization occurs via the file streams' blocking
    read behaviour.
  - Because of file streams' blocking reads, communication between GTP client
    and GTP engine is essentially synchronous. As a consequence, the main thread
    will be blocked if it wants to submit a command to the GTP client while the
    client is still waiting for the response to a previous command. For this
    reason, all GUI elements that trigger a GTP command should be disabled
    while a command is being processed.
  - Read the GtpClient class documentation for details about how GtpClient
    notifies clients of command submission and response receipt.
- GTP command sequence: Even though responses for GTP commands are received
  asynchronously, the commands themselves are processed in the order that they
  are submitted. This means that any number of GTP commands can be submitted as
  fast as possible (i.e. without having to wait for the response), as long as
    1) The submitter does not need the result of the command
    2) A later command does not need the GTP engine to be in a particular state
- Application states and transitions
  - When the application starts up (application:didFinishLaunchingWithOptions:),
    it displays the "Play" view. If the application detects that a game was in
    progress the last time it was running, it loads that game so that the user
    may continue where he has left off. If no game-in-progress is detected, a
    new game is started.
  - When the application becomes suspended (applicationDidEnterBackground:), the
    current user preferences are saved, and the game in progress is written to
    a temporary .sgf file. This is to guard against a forceful shutdown either
    by the user or the system ("purge") while the application is suspended and
    helpless. Nothing special is done to keep the GTP engine running, or to
    shut it down - it is expected that the system simply suspends code
    execution at the appropriate time.
  - When the application is terminated (applicationWillTerminate:), it does
    nothing - the application is expected to always run on multitasking capable
    devices. IPHONE_DEPLOYMENT_TARGET is set to 4.3 to ensure this.
  - When the application resumes (applicationWillEnterForeground:) it clears
    the temporary .sgf file that was written on suspend.
  - When the application becomes inactive (applicationWillResignActive:), it
    suppresses audio/vibration feedback so as not to disturb the user while the
    screen is locked (or an interruption is in progress). In addition, a
    computer vs. computer game is paused.
  - When the application becomes active (applicationDidBecomeActive:), it
    re-enables audio/vibration if these features were disabled due to becoming
    inactive. A paused computer vs. computer game is not automatically resumed,
    though, it must be explicitly resumed by user interaction.
- Preferences: The iOS Application Programming Guide says that "The Settings
  bundle is generally the preferred mechanism for displaying preferences", then
  goes into details about how to use such a Settings bundle. I don't like to
  separate the UI for application preferences from the application, though, and
  therefore chose to implement a dedicated Preferences view inside the
  application.
- The "Play" tab is the centerpiece of the entire application. It has a large
  number of UI elements, many of them interacting with each other, and some of
  them are not visible all the time. To reduce complexity and keep the "Play"
  tab in its entirety in a maintainable state, it is paramount to have many
  small model and controller classes with clearly assigned responsibilities.
  PlayViewController and PlayView are the most generic classes and, as the past
  has shown, have a certain "natural" tendency to attract wildly diverse code
  and become bewildering hotpots. Even though refactoring is always an option
  (and has indeed been used heavily to tame PlayView and PlayViewController),
  it should not be relied upon because there are no automated GUI tests in this
  project. It is therefore better to "get it right" already at the time when a
  new feature is developed.
- UI design: As noted, the "Play" tab has a large number of UI elements, and
  these must somehow be fitted onto the small screeen estate available on the
  iPhone. Here I try to outline the thoughts that went into the iPhone UI
  design:
  - The Go board view
    - The Go board view has the following purposes: 1) Accurately represent
      board positions (in a game that is actively being played, the current game
      state is just a special board position). 2) Provide user interaction so
      that the user can place a stone. 3) Display scoring information (territory
      markup, dead stones, etc.). 4) Provide user interaction so that the user
      can mark dead stones during scoring.
    - Because the Go board is square, but iOS device screens are oblong, the
      game view cannot take full advantage of all the available screen estate.
      The game view is responsible for making the most of the current situation,
      dynamically adjusting to any changes such as device orientation changes.
    - User preferences modify view appearance (e.g. display labels) and user
      interaction behaviour.
  - The toolbar
    - Toolbar space is limited, therefore the only buttons that are displayed
      are those that are actually enabled (e.g. while the computer is thinking
      most actions are not allowed, so the only button that is displayed is the
      one that interrupts the computer's thinking). The result is a "nervous"
      UI, i.e. toolbar buttons are constantly being shown and hidden. I have not
      yet come up with a UI design that is more "calm".
    - At the right-most position there is a "Game Actions" button which provides
      access to an action sheet with additional actions that are not used very
      often. Only actions related to games as a whole are to be displayed on
      this action sheet.
    - At the second-to-right-most position there is a "Game Info" button that
      provides access to a screen with detailed information about the current
      game.
    - The "Game Actions" and "Game Info" buttons remain visible at all times to
      mitigate the "nervous" UI effect described above.
    - Most toolbar items do not use the iOS provided icons available from
      UIBarButtonItem. The reason is that, although the icons' visual appearance
      might seem appropriate, their semantic meaning is not!
  - The status line
    - Currently a status line is situated below the game view, which is used
      to display information about the current game state to the user.
    - The status line uses a relatively small font to make room for the list of
      board positions.
    - Somehow this seems to be rather clunky, I want to find a different way
      how to represent the information in the UI.
  - The activity indicator
    - An activity indicator is needed to let the user know when the Go engine
      is busy so that he knows why some UI elements are disabled.
    - Currently the indicator is located next to the status line. I am not happy
      with this, especially because the activity indicator has a different
      height than the status line, so this might change in the future.
  - The list of board positions
    - This view exists because the toolbar buttons to go back/forward one board
      position make it hard to access board positions that are far away from
      the current board position.
    - A freely scrollable view is more sexy than one that uses paging.
    - Due to size constraints, the additional navigation buttons displayed on
      the iPad do not exist on the iPhone.
- Exceptions: Exceptions should not be used in Cocoa or iOS applications in the
  same liberal way as someone coming from Java or C++ might expect (see [1]).
  In this project, exceptions are occasionally raised, in situations where
  something weird and totally unexpected happened. Most of the time this
  indicates a programming error of some sort which should be fixed immediately.
  Instead of trying to recover from these weird and totally unexpected
  situations, the policy is to fail early. The drawback is that end users will
  see a crash if an exception-triggering bug makes it into production. This is
  a price I am willing to pay, also there is now a crash reporting service in
  place which vastly improves chances that I get notified about the problem.
  [1] http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/Exceptions/Exceptions.html


Coding guidelines
-----------------
- Class names start with an uppercase letter
- Method names start with a lowercase letter
- Member variables use the the prefix "m_" to distinguish them from variables
  that are local to a method
- Use @property in preference to member variables
- Spaces, no tabs
- 2 spaces per indentation level
- Opening/closing braces are placed on their own line
- No space is used to separate opening/closing paranthesis from the expression
  they surround
- Operators (e.g. "+" in string concatenations) are separated by spaces from
  their operands
- Pointers: No space between the type name and the asterisk ("*"); e.g.
  "NSString* foo", not "NSString *foo"
- Use braces liberally to improve readability, but don't hesitate to omit them
  in long if- or switch-clauses that use only one-line statements. Readability
  is the most important aspect here - sometimes the right use of braces can
  create a visual pattern that immediately tells the reader how the program
  flows.
- Only one variable declaration per line
- Only one statement per line; long statements (e.g. method invocations with
  many parameters) may span multiple lines
- Lines should not be longer than 80 characters; for comment lines this limit
  is much stricter than for lines of code
- Setter/getter methods should be named after the property they encapsulate
  (e.g. getter = icon(), setter = setIcon:())
- Private methods and properties of a class are declared in class extension
  which is declared in the .m file
- Consider making properties "readonly" in the public interface of a class, then
  redeclare them as "readwrite" in the private interface in the .m file
- Always declare a property's setter semantics, i.e. explicitly declare "assign"
  even though it is the default and might be omitted
- Use "nonatomic" unless the property really needs to be atomic
- Find good names for variables, methods and classes; don't hesitate to use
  long names; never (!) use abbreviations; don't use i, j, k for loop variables
- Redeclare overrides inherited from a base class
- Method signatures should start in column 0 and use spaces etc. as in the
  following example:
    - (NSString*) foo:(NSString*)bar;
- Never ever use side-effects, e.g.
  - Don't place ++/-- operators in the same line as an assignment
  - Don't test a condition and make an assignment at the same time
- Everything should be documented with Doxygen documentation blocks; exceptions
  are possible but should remain rare


Unit tests
----------
All unit test related files are located in the top-level folder "test".

The Xcode project defines a target "Unit tests" which builds a unit test bundle,
then immediately runs the tests in its "Run Script" phase.

To make the unit tests build & run automatically every time the main target is
built, I usually make sure that in all of my Xcode schemes the checkox "Run" is
checked not only for the main target, but for the unit test target as well.
Note that the same result can also be achieved by a target dependency, which is
saved to the Xcode project file and thus placed under version control.

Notes about the "Unit test" target:
- All tests in this target are what Apple calls "logic tests" (see [1]), i.e.
  unit tests exercise more or less isolated classes. The test source code is
  built using the iOS Simulator SDK, but the tests are run outside of the
  simulator as part of the build process.
- All source code files that are unit tested must be added to the "Unit test"
  target so that they are built for that target.
- The build setting "Header Search Path" is set to the value "./src". Since the
  test sources are completely separated from the normal application sources, I
  don't want to deal with relative path issues for each #import statement. The
  application can be seen as third party software from the point of view of the
  unit test bundle.
- Because application source files depend on the presence of a prefix header,
  the "Unit test" target has to have the same "Prefix header" build settings
  as the main application target.
- Compiling ApplicationDelegate for the "Unit test" target pulls in Fuego/Boost
  (via GTP classes) as dependencies. As a consequence, the "Unit test" target
  must be set up with Header/Library search paths that are the same as in the
  main application target.
  - Additionally, the build setting "Symbols hidden by default" must be set to
    YES to prevent build warnings because of symbol visibility differences
    between Fuego/Boost libraries and the unit test bundle. For some unknown
    reason, this build setting is correct by default in the main application
    target, but incorrect in the "Unit test" target.

A final note about logging: The log file for unit tests run in the simulator
environment is located in
~/Library/Application Support/iPhone Simulator/Documents/Logs.

[1] http://developer.apple.com/library/ios/#documentation/Xcode/Conceptual/iphone_development/135-Unit_Testing_Applications/unit_testing_applications.html


Source code documentation with Doxygen
--------------------------------------
There is a "doxygen" target that can be used to transform the source code
documentation into a set of HTML files. The target uses a shell script that
assumes that Doxygen is installed in

  /sw/bin

This is the standard path for the "fink" project. If you have doxygen installed
somewhere else (e.g. /usr/local/bin) you need to change the target's shell
script.

The Doxygen configuration file is located in

  doxygen/Doxyfile

Notes about the configuration:
- Doxygen recursively searches for *.h, *.m and *.mm files in the project
  top-level folder "src".
- Private methods declared in class extensions or categories in the .m files
  are not included in the documentation process. Change this by setting
  EXTRACT_LOCAL_METHODS = YES inside Doxyfile.
- It is assumed that the command line tool "dot" is available and installed in
    /sw/bin
  dot is part of the Graphviz package and is used to generate a couple of
  diagram types (e.g. class diagrams, collaboration diagrams).


Version control
---------------
The version control system used to maintain this project is Git. The canonical
repository currently resides on GitHub:
- URL for cloning: git://github.com/herzbube/littlego.git
- URL for browsing: https://github.com/herzbube/littlego

The branching model adopted by the project is described in this article:
http://nvie.com/posts/a-successful-git-branching-model/.


Bugtracking
-----------
The bugtracker for the Little Go project is currently located at this URL:
https://bugs.herzbube.ch/.


iOS topics covered in this project
----------------------------------
Little Go uses declared properties, some of them generated, others added
manually. Although declared properties are a language feature introduced to
Objective-C quite some time ago, this is still a new topic for me, which is why
I mention it here. Details can be found in [1].

The Fuego engine runs in a secondary thread, and communication with the engine
also occurs within a secondary thread. Basic understanding of how threading and
run loops work can be found in [2]. Scheduling with NSTimer is covered by [3].

Little Go is quite configurable and has a preference tab to manage all the
settings. This requires the "User Defaults" system (see [4]).

[5] explains the nib object lifecycle. This information is helpful for proper
cleanup during application shutdown. This document also contains information
on how to obtain references to resources embedded in the application bundle
(e.g. sound or image files).

Rendering a Go board in a UIView involves drawing with the Core Graphics and
UIKit frameworks. An introduction to drawing is provided by [6], more specific
information about drawing with Quartz is in [7].

User input is managed by the iOS event handling system. [8] describes how events
and touches are processed by the system on a fundamental level, and how, on a
higher level, gesture recognizer classes help with reacting to specific types
of user input.

[9] and [10] go into detail about the different types of views and view
controllers, and how they can be combined to make a nice and efficient UI. Worth
mentioning are the two sections of special interest that cover animations and
modal view controllers. Table views are such an important topic that an entire
guide [11] has been written about them. Last but not least, the section "iOS UI
Element Usage Guidelines" in [12] provides a useful all-in-one-page overview of
the UI elements and styles available in iOS.

Observing various model objects for user preferences changes can be elegantly
solved using the Key-Value Observing (KVO) technique, which in turn is based on
Key-Value Coding (KVC). The two concepts are extensively documented in [13] and
[14].

Playing short sounds and vibrating the iOS device are covered by [15], while
[16] has additional in-depth information on Audio processing. Playing a system
sound requires the use of Core Foundation data types; getting values from iOS
or Cocoa data types across the boundary into Core Foundation is sometimes as
simple as casting from one type to the other. [17] has details about this
so-called system of "Toll-Free Bridged Types".

[18] is a very good starting point for solutions to rather high-level problems.
Handling documents (including the sync to iTunes) is thoroughly explained in
the subsecion "Files and the File System".

Tasks that should run while the app is in the background are also explained in
[18], in section "Executing Code in the Background". To understand blocks,
which are required for background tasks, a side-trip to [19] and [20] should be
sufficient.

The finishing touch for an app before it is released to the App Store requires
a set of application icons, at least one launch image and an Info.plist file
with that is properly set up. Information on how to get these tasks done can be
found in section "App-Related Resources" of [18], in section "Custom Icon and
Image Creation Guidelines" of [12], and in [21].

Archiving an object graph to a file, and restoring the objects from such an
archive file, is explained in [22].

[23] shows how to use the NSPredicate class to represent logical expressions in
an object form, and how the clever use of predicates can make your code much
more expressive.

A handy feature of the Objective-C runtime is called "Associative references":
It allows to attach an object reference to another object under a certain name,
and to retrieve the referenced object at a later time, e.g. in a delegate
method. The required C functions are documented in [26].

Unless otherwise noted, the base for all of the following references is the
"iOS Developer Library", found under this URL:
https://developer.apple.com/library/ios/navigation/.

[1]  iOS Developer Library > Guides > The Objective-C Programming Language > Declared Properties
[2]  iOS Developer Library > Guides > Threading Programming Guide
[3]  iOS Developer Library > Guides > Timer Programming Topics
[4]  iOS Developer Library > Guides > User Defaults Programming Topics
[5]  iOS Developer Library > Guides > Resource Programming Guide
[6]  iOS Developer Library > Guides > Drawing and Printing Guide for iOS
[7]  iOS Developer Library > Guides > Quartz 2D Programming Guide
[8]  iOS Developer Library > Guides > Event Handling Guide for iOS
[9]  iOS Developer Library > Guides > View Programming Guide for iOS
[10] iOS Developer Library > Guides > View Controller Programming Guide for iOS
[11] iOS Developer Library > Guides > Table View Programming Guide for iOS
[12] iOS Developer Library > Guides > iOS Human Interface Guidelines (aka "HIG")
[13] iOS Developer Library > Guides > Key-Value Observing Programming Guide
[14] iOS Developer Library > Guides > Key-Value Coding Programming Guide
[15] iOS Developer Library > Reference > System Sound Services Reference
[16] iOS Developer Library > Guides > Multimedia Programming Guide
[17] http://developer.apple.com/library/mac/#documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html
[18] iOS Developer Library > Guides > iOS Application Programming Guide
[19] iOS Developer Library > Getting Started > A Short Practical Guide to Blocks
[20] iOS Developer Library > Guides > Blocks Programming Topics
[21] iOS Developer Library > Reference > Information Property List Key Reference
[22] iOS Developer Library > Reference > Archives and Serializations Programming Guide
[23] iOS Developer Library > Guides > Predicate Programming Guide
[24] iOS Developer Library > Guides > Predicate Programming Guide
[25] https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html


Compilation command
-------------------
TODO: Update this section for Xcode 4.

The following lines represent the command used by Xcode 3 to compile a single
.cpp file in Debug configuration for the iPhoneSimulator platform. Every line
contains one compiler switch or command-line argument.

/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin/gcc-4.2
-x c++
-arch i386
-fmessage-length=0
-pipe
-Wno-trigraphs
-fpascal-strings
-fasm-blocks
-O0
-Wreturn-type
-Wunused-variable
-DNDEBUG
-isysroot /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator4.2.sdk
-fexceptions
-fvisibility=hidden
-fvisibility-inlines-hidden
-mmacosx-version-min=10.6
-gdwarf-2
-D__IPHONE_OS_VERSION_MIN_REQUIRED=40200
-iquote "/Users/patrick/Documents/dev/littlego/build/Little Go.build/Debug-iphonesimulator/Little Go.build/Little Go-generated-files.hmap"
"-I/Users/patrick/Documents/dev/littlego/build/Little Go.build/Debug-iphonesimulator/Little Go.build/Little Go-own-target-headers.hmap"
"-I/Users/patrick/Documents/dev/littlego/build/Little Go.build/Debug-iphonesimulator/Little Go.build/Little Go-all-target-headers.hmap"
-iquote "/Users/patrick/Documents/dev/littlego/build/Little Go.build/Debug-iphonesimulator/Little Go.build/Little Go-project-headers.hmap"
-F/Users/patrick/Documents/dev/littlego/build/Debug-iphonesimulator
-I/Users/patrick/Documents/dev/littlego/build/Debug-iphonesimulator/include
-I3rdparty/install/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator4.2.sdk/include
"-I/Users/patrick/Documents/dev/littlego/build/Little Go.build/Debug-iphonesimulator/Little Go.build/DerivedSources/i386"
"-I/Users/patrick/Documents/dev/littlego/build/Little Go.build/Debug-iphonesimulator/Little Go.build/DerivedSources"
-include /var/folders/K+/K+NmKFX-FA4IgmDBY9aGdk+++TM/-Caches-/com.apple.Xcode.502/SharedPrecompiledHeaders/Little_Go_Prefix-gatqaltedfwqgcbkvwvyfnixuhqh/Little_Go_Prefix.pch
-c /Users/patrick/Documents/dev/littlego/src/MyClass.cpp
-o "/Users/patrick/Documents/dev/littlego/build/Little Go.build/Debug-iphonesimulator/Little Go.build/Objects-normal/i386/MyClass.o"

Discussion of options not used in 3rdparty builds:
-x c++
  The language of the source file. No need to set this, so far I am happy with
  the default language selection of the compiler.
-fmessage-length=0
  Error messages are not line-wrapped. No need to set this, has no influence on
  the code produced.
-Wno-trigraphs
  A warning. No need to set this, has no influence on the code produced.
-fpascal-strings
  APPLE ONLY. Allow Pascal-style string literals. No need to set this, this is
  arcane and as far as I'm concerned have no influence on the code produced.
-fasm-blocks
  APPLE ONLY. Allow assembly code within a C/C++ file. No need to set this,
  this is arcane and as far as I'm concerned have no influence on the code
  produced.
-O0
  Optimization. This is set differently for 3rdparty libraries by design.
-Wreturn-type
  A warning. No need to set this, has no influence on the code produced.
-Wunused-variable
  A warning. No need to set this, has no influence on the code produced.
-fexceptions
  Enable exception handling. No need to set this, is already enabled by default
  for languages like C++ that support exceptions.
-mmacosx-version-min=10.6
  Same as MACOSX_DEPLOYMENT_TARGET.
-D__IPHONE_OS_VERSION_MIN_REQUIRED=40200
  No need to set this, iOS target version for 3rdparty libraries is defined
  via IPHONE_DEPLOYMENT_TARGET.
-iquote /some/include/path
  Specifies that this include path is searched for includes that were specified
  with quotes, but not for those specified with angle brackets (<>). No need to
  set this, has no influence on the code produced.


Boost build/installation issues
-------------------------------
No issues, build works out of the box.


Fuego build/installation issues
-------------------------------
Build
- The build script needs to specify the configure flag --with-boost-libdir,
  otherwise configure aborts with a linker error.

Installation
- "make install" only copies the executables (fuego, fuego_test), but not the
  libraries nor the headers. The build script for Fuego applies a patch that
  modifies a number of Makefile.am files. The changes made are to rename the
  "noinst_LIBRARIES" property to "lib_LIBRARIES", and to rename the
  "noinst_HEADERS" property to "pkginclude_HEADERS". Notes:
  - Libraries are installed under
      <prefix>/lib
  - Headers are installed under
      <prefix>/include/fuego
    because "pkginclude" is used instead of "include"
  - I would have preferred to keep sub-folders, e.g.
      <prefix>/include/fuego/gtpengine
    In theory, to make this work it should be possible to use
    "nobase_pkginclude_HEADERS". In practice, however, this does not work, the
    "nobase" prefix has no effect. The reason for this is unknown. I have tried
    the following combinations, but could not get it to work as desired:
      pkginclude_HEADERS     -> installs into include/fuego/*
      nobase_include_HEADERS -> installs into include/*
      nobase_dist_HEADERS    -> installs into include/*
- In addition, the build script creates and installs a single unified library
  that contains all the object files within Fuego's separate library files.


CocoaLumberjack build/installation issues
-----------------------------------------
No issues, build works out of the box.


ZipKit build/installation issues
--------------------------------
No issues, build works out of the box.


QuincyKit build/installation issues
-----------------------------------
QuincyKit comes pre-built, so no build is necessary.

Installation
- QuincyKit does not consist of the usual header + library files that can be
  installed into split locations (include/lib) within platform-specific folders
  (Developer/Platforms/iPhoneOS.platform/...). Instead, QuincyKit includes a
  framework (CrashReporter.framework) and a bundle (Quincy.bundle) which need to
  be added to the Xcode project as a whole, and regardless of which platform
  the project is built for.
- For this reason, the necessary QuincyKit files are copied into the folder
  3rdparty/install/quincykit, and the Xcode project references the files
  from there


Changes to the Fuego source code
--------------------------------
1) FuegoUtil::FuegoMain()
- Create a new function FuegoUtil::FuegoMain(int argc, char** argv) in
  FuegoUtil.cpp and FuegoUtil.h
- Move the implementation in main(int argc, char** argv) from FuegoMain.cpp to
  this new function in FuegoUtil.cpp
- Also move the other support functions from FuegoMain.cpp to FuegoUtil.cpp
- Invoke FuegoUtil::FuegoMain() from main()

2) Add 2 new command line options "--input-pipe /path/to/pipe" and
   "--output-pipe /path/to/pipe"
- Basic option support requires modification to ParseOptions() and introduction
  of two new global variables
- Actual usage of the specified pipes requires modification to FuegoMain().
- Additional option support to check for mutually exclusive options
  (--input-file and --input-pipe) requires addition of a new function
  MutuallyExclusiveOptions() which is invoked from ParseOptions()

3) Remove usage of exit() in Help()
- ParseOptions() must be modified to return a value that indicates to its
  caller (FuegoMain()) whether the program should continue running or whether
  it should be terminated

4) Add 2 new GTP commands "list_moves" and "list_handicap"
- These commands are used to discover the move history and the list of handicap
  stones after Fuego has been instructed over GTP to load an .sgf file (with
  the "loadsgf" GTP command)
- This change allows Little to fully delegate all .sgf file handling to Fuego


Fuego Patches
-------------
The changes to the Fuego build system (Makefile.am files) and source code
are captured in a series of patch files that are stored in the top-level folder
"patch". The patches must be applied incrementally, in the order indicated by
the patch file name. Each file name starts with a numerical prefix to make the
order explicit.

Patches are automatically applied during the 3rdparty software build (cf.
section "3rdparty software build" in this file).

Patches are created like this:
  diff -ruN fuego-1.0-original fuego-1.0-new >fuego.patch

Patches are applied like this:
  cd fuego-1.0
  patch -p1 <fuego.patch


CocoaLumberjack Patches
-----------------------
The only patch currently needed is the one that adds a static library Xcode
project. This project is then used by the build to actually produce the
libCocoaLumberjack.a file that Little Go links against.


GTP engine profiles
-------------------
The application's UI exposes a few GTP engine settings to the user. These are
aggregated into a "profile" that can be attached to a computer player. The
profile thus defines the playing strength/behaviour of the computer player.
Aggregation of settings is implemented in the GtpEngineProfile class.

Note: In the UI we always use the term "profile", not "GTP engine profile".

Profile settings are applied to the GTP engine only when a new game is started.
The reason for this is mainly laziness - if we do it this way we don't have to
think about the consequences of changing fundamental parameters in mid-game.

In a computer vs. computer game, where we have two computer players with
potentially different settings, the user can choose which player's settings
should take precedence. In a human vs. human game where no player has an
attached profile, the settings from a hardcoded default profile are applied.
The default profile can never be deleted by the user so that a fallback is
always available.

Notes about default values
- fuegoMaxMemory = 32
  - I own an iPhone 3GS, and a 1st generation iPad, according to [2] both of
    them have 256 MB RAM
  - Tests on my iPhone 3GS have shown that 128 MB is too much - the app very
    quickly gets memory warnings and then is killed by the system
  - 64 MB seems to be a more acceptable value - I have run an entire computer
    vs. computer game with that setting without any problems. There were reports
    from beta testers, though, that indicate that even 64 MB is too much
  - 32 MB is therefore the conservative default value that should make sure
    that new users don't get aggravated by unexpected crashes
- fuegoThreadCount = 1
  - [1] recommends to set this to the number of cores
  - According to [2], the iOS devices I own only have one core
  - The upcoming A5 processor will have 2 cores [3]
- fuegoPondering = true
  - [1] recommends this for best performance
- fuegoReuseSubtree = true
  - [1] recommends this for best performance


[1] http://sourceforge.net/apps/trac/fuego/wiki/FAQ1
[3] http://en.wikipedia.org/wiki/List_of_iOS_devices
[3] http://en.wikipedia.org/wiki/Apple_A5


Notes on media files
--------------------
I have no artistic fibre in me, and I am just terrible at being creative and
producing any kind of media files. Therefore I like to keep an account of how I
got the stuff into the shape it is now, just in case I need to make changes in
the future.

wood-on-wood-12.aiff:
- Record various wood-on-wood sounds with an iPhone. Obviously the environment
  has to be sufficiently quiet to get a clean recording - 2am should be about
  the right time for doing this, after all the noisy neighbours have gone to
  bed :-) As there is still a bit of ambient noise, the recording should contain
  a few seconds of only noise. This will help later on during sound editing.
- Sync with iTunes, then convert the recordings to .aiff (also in iTunes).
- Start editing the sound files with Audacity. The first thing to do is to
  listen to all the recordings and select one with an effect that sounds nice
  and crisp.
- Sound editing consists of two steps only: Noise removal, and trimming to the
  correct level. Noise removal first requires that a stretch of the recording
  is selected that consists of only noise. Next select the "Noise Removal" tool
  (found in the Audacity's "Effects" menu) and click the "Get Noise Profile"
  button. After the dialog has closed, select the entire recording then reopen
  the tool a second time. The values should now be correctly adjusted to the
  noise level in the recording, so that you can simply click the "OK" button.
  After the tool has applied its effect, you can playback the recording to
  confirm that the noise has really been eliminiated.
- Select the portion of the recording that you want to use as the media file.
  Select "File > Export Selection", in the following dialog click the "Clear"
  button to remove the metadata stored by the iPhone in the recording, then
  save under "AIFF (Apple) signed 16 bit PCM". This is one of the few formats
  that the System Sound Services function AudioServicesPlaySystemSound() is
  capable of playing.

Icon files
- The canonical source for information about icons are Apple's Human Interface
  Guidelines (HIG) [1]. The following notes replicate much of the information
  found there.
- A dark'ish foreground color of #444444 painted on transparent background works
  well for images that are loaded into a UIBarButtonItem or a UITabBarItem. The
  reason for this is that according to the HIG, images used in toolbar,
  navigation bar and tab bar items are used as "template" images only, i.e. iOS
  uses them as a mask to create the actual icon displayed to the user.
- For UIBarButtonItem, the main image should be 40x40 pixels because the size of
  toolbar and navigation bar images is 20x20 points. On a retina display, this
  corresponds to 40x40 pixels. For regular displays, the image can be scaled
  down to 20x20 pixels.
- For UITabBarItem, the size is 60x60 for high resolutions, and 30x30 for low
  resolutions.
- To make use of iOS automatic clever image selection, save the images under
  the following names:
    foo.png    - normal image
    foo@2x.png - retina display image
- Whenever you need to load an image just use the normal image name and iOS will
  check behind the scenes if there is a retina display image available when it
  could use one.
- To create the actual images I use either the Gimp or Inkscape. The .xcf and
  .svg files are currently not part of the project.

stone-black.png, stone-white.png, stone-crosshair.png
- The original source for these files is the file stones.svg, which in turn
  is a modified copy from the "Dragon Go Client" iOS app project [2]. The app
  author Justin Weiss gave permission to use the artwork in an email in
  August 2012.
- What is the minimum size that we need for stone images?
  - The smallest board size is 7x7
  - The largest retina screen resolution on any iOS device currently is
    2048x1536
  - The board is square so we need to take the smaller dimension 1536 and
    subtract maybe 100 for margins...
  - 1436 / 7 is about 205, so let's round this up to (at least) 220x220 for the
    retina image, and 110x110 for the normal image
- The workflow to get the .png files is this:
  - Open the original stones.svg from the DGS project in Inkscape
  - The original stones.svg contains artwork for a black and a white stone.
    The artwork at the time of writing is sized 294x294, i.e. sufficient for
    the minimum size that we need for stone images
  - Make a copy of the objects that make up the black stone. This is our basis
    for creating the third piece that we need to draw the blue cross-hair stone
  - Make sure that the objects that make up the three stones are all aligned in
    exactly the same way. This is important so that the images later on can all
    be treated in the same way (e.g. they all have the same center).
  - Adjust colors for the cross-hair stone
    - Select the object in the stone layer
      - Display "Fill and Stroke" settings
      - Duplicate the gradient, then edit the gradient
      - Gradient stop 1: In the RGB color settings change the value for blue
        to 255
      - Gradient stop 2: Change the value for blue to 200
    - Repeat the steps for the object in the highlight layer (including the
      exact same values for blue)
  - Repeat the following steps three times to get the three stone image files
    - Select all objects that together make up a stone
    - Select the function "File > Export Bitmap"
    - Make sure that the export area is set to "Selection"
    - The bitmap size should have been automatically set to 294x294. Also make
      sure that 90dpi is selected.
    - Export to the appropriately named .png
- Additional notes
  - When the images obtained in this way are drawn to the screen, they are
    scaled to different sizes for different boards and different devices.
    As a result the scaled version of an image sometimes is not properly
    centered on an intersection. The Play view drawing routines compensate for
    this with a translation of the CTM. The values used for translation have
    been experimentally determined and are hardcoded.


[1] http://developer.apple.com/iphone/library/documentation/UserExperience/Conceptual/MobileHIG/IconsImages/IconsImages.html
[2] https://github.com/justinweiss/dragongoclient


Working with .sgf files
-----------------------
The GTP commands "loadsgf" and "savesgf" are used to tell the GTP engine that it
should load or save a game from/to a specified filename. Unfortunately, due to
limitations of the GTP protocol not just any path/filename can be specified.
Notably, the path/filename may not contain spaces, hash signs (#) or control
characters.

The workaround here is to let the GTP engine load from/save to a temporary
file that is in a well-known location and whose filename/path does not violate
any of the GTP protocol restrictions. The application performs the necessary
pre-/post-processing via the NSFileManager API, which has none of the GTP
protocol limitations.

NSFileManager pre-/post-processing:
- Load game: Copy the real .sgf file to the well-known temporary file, from
  where it can then be loaded using the "loadsgf" GTP command. After the game
  has been loaded, the temporary file is removed.
- Save game: The "savesgf" GTP command is used to save the game to the
  well-known temporary file. After the game has been saved, the temporary file
  is moved to its real location.

This approach allows to keep the .sgf files in the application's documents
folder (which may contain spaces in its path), where they need to be located
for iTunes's syncing to work. It also allows to use arbitrary characters in the
filename, including unicode characters which might otherwise be interpreted as
control characters when sent over the GTP protocol wire.

Experiment has shown that the application's document folder is at the following
path locations:
- iOS Simulator environment
  /Users/<username>/Library/Application Support/iPhone Simulator/4.2/Applications/03C363CC-7330-40A0-A382-74FEA08E6C29/Documents
- iPhone device
  /var/mobile/Applications/FD1CCC4F-ECD3-43D8-87B9-359A4CCBFA87/Documents

Design note for code that needs to work with files
- The code should never assume that the current working directory is set to a
  specific location
- The code should not change the current working directory, unless absolutely
  necessary; working with absolute paths often obviates this need
- If the current working directory must indeed be changed, it should be changed
  back to the original location after the desired purpose has been achieved


The version number
------------------
The application's version number is stored in the bundle's Info.plist file.
According to Apple's "Information Property List Key Reference" (available at
[1]), there are two keys that are relevant for versioning:
- CFBundleShortVersionString: A string consisting of three period-separated
  integers. This key refers to the so-called "release version number".
  Apparently it is possible to localize this string, but why one would want to
  do this is beyond me (also the specification "three period-separated integers"
  in my opinion does not leave any room for localization). Xcode 4 displays the
  value of this key on the "Summary" page of each target, as the field labeled
  "Version".
- CFBundleVersion: A monotonically increased string consisting of of one or
  more period-separated integers. This refers to the so-called "build version
  number". Xcode 4 displays the value of this key on the "Summary" page of each
  target, as the field labeled "Build".

Although I don't have a use for CFBundleVersion, and the Xcode user guide
(section "Building and Running Your Code") does not even mention it, the App
Store validation process forces me to add this key to Info.plist.

[1] developer.apple.com/library/mac/#documentation/General/Reference/InfoPlistKeyReference/
[2] http://developer.apple.com/library/ios/#documentation/ToolsLanguages/Conceptual/Xcode4UserGuide/Building/Building.html


Application icons
-----------------
Application icons are specified using various keys in the bundle's Info.plist
file. Some notes about the keys:
- The app does not support iOS versions prior to 4.3, so there is no need to
  add the key "CFBundleIconFile", nor to use fixed icon filenames
  (e.g. "Icon.png")
- The app supports iOS versions prior to 5.0, so the key "CFBundleIconFiles"
  must be included
- For iOS 5.0 and later the key "CFBundleIcons" is included (takes precedence
  over "CFBundleIconFiles")

I tried (but failed!) to add the app icons by manually editing Info.plist and
adding just the base icon name without the .png file extension. Two motivations
for this:
- Take advantage of the system's automatic detection mechanism to find the
  retina display icon by adding the suffix "@2x"
- Allow the icon files to reside in the "resource" subfolder, together with the
  rest of the icons. The files need to be at the app bundle's root folder only
  when the app bundle is built and deployed.

Unfortunately this did not quite work as expected:
- In Xcode on the main target's summary page, no icons are displayed. Although
  a bit unfortunate, I could live with this mis-behaviour.
- Much more of a problem is that sometimes Xcode incorrectly deploys the app
  bundle to the retina display iOS simulator, and also my retina display test
  device. The simulator and the real device would sometimes display the normal
  resolution icon, and sometimes the correct high resolution icon.
- I spent only a limited amount of time testing this. Tests were of a
  "try & error" nature and included: Completely remove the app bundle from the
  device, re-deploy the bundle, restart Xcode.
- In the end I did not manage to pin down an exact mechanism for when it works
  and when it doesn't.

For the moment I have therefore decided not to try and fight the system, but
instead follow a path with reproducible results, even if I am not very happy
about the consequences. This means:
- Icons need to be added in Xcode 4 on the main target's summary page
- There are two placeholders: one for the normal and one for the retina display
  icon. The icons can be added by dragging the image files onto these
  placeholders.
- When a file is dragged onto its placeholder, Xcode will insist on placing a
  copy of the file into the project's top-level folder
- This means that it is not possible to keep the icon files in the "resource"
  folder, together with the other bundle resources
- Another consequence is that Xcode adds explicit filenames to Info.plist, i.e.
  it is not possible to take advantage of the system's automatic detection
  mechanism to find the retina display icon (suffix "@2x").


Launch images
-------------
Launch images are specified using various keys in the bundle's Info.plist
file. Unlike with application icons, I had no trouble specifying just the base
image name and let iOS do the rest for me. Specifically:
- Use the key "UILaunchImageFile" and set the base name to "LaunchImage"
- iOS will automatically tack on the file extension ".png", and it will also
  automatically find the retina display image by adding the suffix "@2x".

Note that in Xcode 4 the launch images do not show up on the main target's
summary page. Apparently Xcode does not support iOS' automatic way of finding
alternative images.


How to use the diagnostics information file sent as part of a bug report email
------------------------------------------------------------------------------
Preparation work
- Make sure to get the sources for the exact version of Little Go that the user
  had when he generated the diagnostics information file
- Make a debug build & run that build in the simulator version that most closely
  matches the user's device.
- Stop the app. This first run was just to make sure that the app bundle is
  installed in the simulator
- Locate the app bundle folder in the Finder. For instance, on my system with
  Xcode 4.2 and using the current 4.3 simulator the folder is located here:
  /Users/patrick/Library/Application Support/iPhone Simulator/4.3.2/Applications/5A454C1C-1339-494A-8CDD-9DBF1FCB85D6/Little Go.app
- Place a copy of the diagnostics information file into the
  "Library/Application Support" folder which is located parallel to the
  simulator app bundle

Run the debug build you made earlier in the preparation phase. The following
things will happen:
- The application delegate detects the presence of the diagnostics information
  file and performs the following special startup sequence
- RestoreBugReportUserDefaultsCommand is executed to restore user defaults
  that were extracted from the diagnostics information file
- User defaults are then loaded in the usual way
- RestoreBugReportApplicationState is executed instead of RestoreGameCommand;
  more stuff is extracted from the diagnostics information file to bring the
  application back to the exact state it was in when diagnostics information
  file was generated

Once the application has launched you are ready to test & debug.


Crash Reporting
---------------
Little Go currently uses QuincyKit [1] for crash reporting. QuincyKit is free
and open source, but the deciding factor has been that it allows me to send
crash reports to my own server. If you are creating a clone of Little Go, make
sure to change the submission URL that appears in ApplicationDelegate.mm to a
server that you control.

Bugsense [2] is the alternative that should be considered should there ever be a
need to replace QuincyKit. Although the Bugsense library itself is not open
source, they are friendly to open source projects and offer them their Plus
package (which normally costs a hefty fee) for free.

QuincyKit integration into the Little Go app (= the client) has been very easy
and is described in [3]. Setting up the QuincyKit server is also described in
[3] and pretty much a no-brainer. The default setup, however, leaves the admin
web interface completely unprotected against anonymous access from the Internet.
On [4] I have outlined how to protect the admin interface via HTTP
authentication.

Symbolication of a crash report is described in [3]. For easy reference I am
reproducing the steps here:
- From the extracted QuincyKit package, copy the content of the "server/local"
  folder to your dev machine
- If necessary, make the symbolication script executable:
    chmod + x symbolicatecrash.pl
- Copy the crash log file to the dev machine
- The following command symbolicates the crash log file and prints the result
  to stdout
    symbolicatecrash.pl /path/to/crashlogfile
- For this to work, the following packages must be present somewhere on the dev
  machine:
    Little Go.app
    Little Go.app.dSYM
  Obviously, the packages must match the build that the crash log file comes
  from. The symbolication script tries to find the packages by peeking into the
  Spotlight index and looking up the appropriate packages by UUID. If you have
  an archived build hanging around on the machine, the script will find it and
  use the packages from inside the archive.
- You can also specify the folder that contains the necessary packages:
    symbolicatecrash.pl /path/to/crashlogfile /path/to/packagefiles
  I have never had to use this, so I don't know how this works.

Once you have local symbolication up and running, you can add remote
symbolication by doing the following:
- Modify serverconfig.php so that it contains the necessary details to access
  the QuincyKit server that receives crash log files from clients. NOTE: I was
  unable to get this to work with HTTPS access.
- Try whether this works by running
    php symbolicate.php
  Apparently this prints some error message which can be ignored.
- Log in to the QuincyKit server admin web interface. If everything was set up
  correctly, you should see that the crash log files on the server are now
  symbolicated.

Once remote symbolication works, you can take it one step further and add
automation to the process:
- Modify symbolicate.sh and com.crashreportsender.symbolicator.plist so that
  they contain the proper paths
- Make the shell script executable:
    chmod + x symbolicate.sh
- Start automation for the current user:
  cp com.crashreportsender.symbolicator.plist User/Library/LaunchAgents
  launchctl load com.crashreportsender.symbolicator.plist
- Remote symbolication should now run every 15 minutes. If you want a different
  interval you can change this in the .plist. file.

[1] http://quincykit.net/
[2] http://www.bugsense.com/pricing
[3] https://github.com/TheRealKerni/QuincyKit
[4] http://wiki.herzbube.ch/index.php/QuincyKit


Strategy for saving data / preventing data loss
-----------------------------------------------
There are two types of data that need to be saved:
- Preferences data. This data is saved by the app itself. The function doing
  this is ApplicationDelegate::writeUserDefaults().
- The game in progress (as an .sgf). Saving this data is delegated to the Fuego
  engine. This is done in BackupGameCommand.

Before 0.9.0 the strategy simply was to save data when the application is
suspended (applicationDidEnterBackground), and to restore it when the
application did launch (application:didFinishLaunchingWithOptions:()). This
strategy is sufficient for the normal application lifecycle, but has one severe
weakness: It assumes that the application never crashes!

From 0.9.0 onwards, the strategy was changed to cope with crashes that might
occur at - almost - any time. It goes like this:

- The game in progress is saved after each move, overwriting the .sgf file from
  the previous backup operation. This gives maximum protection against crashes
  (assuming that there is no crash during the game-saving routine itself), for
  the price of additional file activity and processing power. I have not
  measured the impact with Instruments, but for the moment I assume that it is
  not too high: 10 KB of data saved for a large game doesn't seem too much, and
  the processing power used for the backup should be neglible in comparison to
  Fuego's consumption.
- Preferences data is saved only when the user switches tabs. This is not as
  thorough as saving the game in progress, but it should be sufficient. It would
  have been a larger effort to introduce events for each and every preferences
  change, so I have decided to go for the optimization with the tab changes - an
  event which is simple to detect. I am also assuming that 1) losing a bit of
  preferences data in case of a crash is not as grave losing the game in
  progress (imagine you lose a game of several hours), and 2) that changing
  preferences is a relatively well-tested process that is not likely to trigger
  a crash, so saving data can wait until the user switches tabs to do other,
  potentially more dangerous things.

With the introduction of board positions in 0.10.0, it has become essential that
the game in progress is backed up as outlined above. Whenever the board
position changes, the state in Fuego is sync'ed with the new board position.
If the user goes back in the move history, it is therefore vital that no
"savesgf" GTP command is sent at this point because this would overwrite the
actual game state with the older board position.
