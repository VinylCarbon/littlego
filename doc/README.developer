Purpose of this document
------------------------
This document is the starting point for developers that want to familiarize
themselves with the "Little Go" project, i.e. developers that are new to the
project, and also me, after I come back to the project after several months
or years :-)


Folder structure
----------------
<root>
 +-- doc               This folder contains documents not relevant for building
 |                     the "Little Go" binary; some of these files (such as
 |                     LICENSE) are included in the application bundle that is
 |                     distributed on the App Store.
 +-- doxygen           This folder contains a configuration file Doxyfile for
 |                     Doxygen; the folder is intended to receive the files
 |                     generated by Doxygen.
 +-- English.lproj     This folder contains the project's English .xib files.
 +-- src               This folder contains the project's source code.


Document reference
------------------
Documents described here are located in the Documents folder.

README
  This document is the starting point for end users. It provides a quick
  overview of what "Little Go" is about, points to other interesting documents
  of the project, and also contains other important information that should be
  immediately accessible to new or recurring users.

INSTALL
  This document provides instructions on how to obtain a copy of the source code
  of "Little Go" and how to build the project with Xcode into an executable
  application.

TODO
  This document contains a list with not-so-important features (aka
  "good ideas" :-); the list is sorted by priority, which provides a rough
  indicator in what order the features should be implemented. Things listed
  in the Roadmap are much more important and should be implemented before
  things in TODO.

Roadmap
  This document contains a list with important features and the order in
  which they should be implemented. The purpose of this list is to avoid
  distraction by the "good ideas" listed in TODO, which may sometimes be more
  attractive to implement but are not this important.

ChangeLog
  This document should not duplicate SCM log messages. Its entries should be
  rather high-level so that it can be used as a source for release notes, e.g.
  to populate the "Changes in this release" section in the README document.
  Examples for things that should be included in the ChangeLog:
  - Fixes for distinct bugs, with or without a bug report in the bug tracker
  - New features, with or without a bug report in the bug tracker
  - Other "big" changes that are noticable by the users of the software
    (e.g. the program icon has changed)
  - Things that may not be noticable but that need to be brought to the
    attention of the users of the software (e.g. a license change)

ReleaseSteps
  This document lists the steps needed to make a project release.


Other files
-----------
dgsmonX.xcodeproj
  The Xcode project file. The format is "Xcode 3.1-compatible".

Info.plist
  The information property list file that describes the dgsmonX application
  bundle.

RegistrationDomainDefaults.plist
  Contains default preferences that should be used if the user has never
  opened the "Preferences" dialog.

makedist.sh
  Helper script for creating both the binary and the source distribution. Used
  when a release is made.


Build system configuration
--------------------------
Project-wide configuration changes in Xcode:
- SDKROOT = macosx10.4
  - See "Platform notes" further down
- GCC_PRECOMPILE_PREFIX_HEADER = YES
- GCC_PREFIX_HEADER = Sources/dgsmonX_Prefix.pch
- PREBINDING = NO
  - This is disabled because dgsmonX targets Mac OS X 10.4 and later. In
    Mac OS X 10.4, dyld has been improved so that prebinding is no longer
    necessary (or even useful).
  - See information in: ADC Home > Reference Library > Guides > Performance
                                 > Tools > Launch Time Performance Guidelines
                                 > Prebinding Your Application
- GCC_ENABLE_OBJC_EXCEPTIONS = YES
- GCC_WARN_ABOUT_RETURN_TYPE = YES
- GCC_WARN_UNUSED_VARIABLES = YES

Target-specific configuration changes:
- None


Platform notes
--------------
- The Xcode project is prepared to build dgsmonX as a universal binary. The
  setup is simple: Both the PPC and the Intel binaries are built with the same
  target. The minimum requirement for building an Intel binary is the
  "MacOSX10.4u" SDK. Since the PPC build uses the same target, it also uses the
  same SDK.
- The source code uses very few Cocoa APIs only available from Mac OS X 10.4 or
  later. It might be possible to eliminate those so that we could use the
  10.3.9 SDK for the PPC build, but so far there was no need for that. It would
  certainly not make sense to go back even further to the 10.2 API, because we
  heavily use Cocoa bindings in the .xib file and we don't want to lose that.
- The .xib file requires Mac OS X 10.4 or later. Notes about specific content
  of the .xib file:
  - The "+" and "-" buttons on the second page of the Preferences dialog are of
    a type that exists only since Mac OS X 10.4
  - Cocoa bindings are an essential part of the .xib file; Cocoa bindings are
    supported since Mac OS X 10.3
  - Interval text fields are configured each with an NSNumberFormatter that is
    set to use the Mac OS X 10.4+ behaviour
- Exceptions, used lightly in dgsmonX, require Mac OS X 10.3 or later.


MainMenu.xib design notes
-------------------------
I find it difficult to remember some specialities about the UI design in
MainMenu.xib. The following notes are to MainMenu.xib what inline documentation
is to source code:
- The text view window has a minimum size. In addition, it is anchored to the
  top-right screen edges so as to open close to the application's status item
- UI element sizes in the Preferences window
  - The window has a minimum size. Anchoring the window to the top-right screen
    edges in the same way as the text view window does not work, probably
    because the Preferences window is displayed as a modal dialog.
  - On the "General" tab, the spacing between the radio button group and the
    "Display opponent name" is arbitrary - just what looks good to me. There
    are no guides that give a hint about what would be a good spacing.
  - On the "General" tab I have placed a custom guide that is used to snap the
    upper border of the "Play sound" check box into place. The check box thus is
    positioned properly in relation to the title animation interval text field.
- Cocoa Bindings in the Preferences window
  - Data sources are an instance of NSArrayController (for DGSMonXServer
    objects) and NSUserDefaults (for all other options).
  - On the "Servers" tab, the "Test" button does not represent an attribute of
    the selected server, yet it must be disabled when no server is selected.
    To achieve this, the button's "Enabled" binding is attached to the
    controller key "canRemove" of the NSArrayController.


Implementation notes
--------------------
- Error handling: Any method that encounters an error condition that it cannot
  handle properly may post the notification errorConditionOccurredNotification
  (defined in DGSMonXGlobals.h). DGSMonXController is the handler class that
  listens for the notification. When it receives the notification, the problem
  is immediately escalated to the user: The user is presented with a dialog that
  offers terminating the application (the default), or simply ignoring the error
  (not recommended).
- Thread synchronization: Game state checks are performed by a monitoring
  thread and Cocoa's URL Loading System, not the main thread, so as not to
  block the GUI while checks are running. Communication between the main thread
  and the monitoring thread happens through the use of NSConnection and NSPort,
  which are part of Cocoa's Distributed Objects system and make the use of
  mutexes for thread synchronization unnecessary (synchronization still happens
  somewhere within Cocoa, but it is not the responsibility of the application).
  The advantage of using NSConnection and NSPort is a simpler implementation
  on the application side. The price to pay is that the GUI thread will block if
  the user attempts an operation that needs to invoke a method in the context
  of the monitoring thread, while at the same time some part of the game state
  check is processing also in the context of the monitoring thread.
- Memory management: Still uses retain/release, i.e. no automatic garbage
  collection.
- It is important that the following order of things is not changed in
  DGSMonXController's class method initialize():
  1) Register for applications specific notifications, especially
     errorConditionOccurredNotification so that an error handling instance is
     present already at a very early stage
  2) Invoke DGSMonXPreferences's class method setupDefaults(). The existence of
     sensible user defaults in the NSRegistration domain is important for other
     classes


Coding guidelines
-----------------
- Class names start with an uppercase letter
- Method names start with a lowercase letter
- Member variables use the the prefix "m_" to distinguish them from variables
  that are local to a method
- Spaces, no tabs
- 2 spaces per indentation level
- Opening/closing braces are placed on their own line
- No space is used to separate opening/closing paranthesis from the expression
  they surround
- Operators (e.g. "+" in string concatenations) are separated by spaces from
  their operands
- Lines should not be longer than 80 characters; for comment lines this limit
  is much stricter than for lines of code
- Setter/getter methods should be named after the property they encapsulate
  (e.g. getter = icon(), setter = setIcon:())
- Private methods of a class are declared in a category named "Private" which is
  declared in the .m file
- Everything should be documented with Doxygen documentation blocks


Source code documentation with Doxygen
--------------------------------------
There is a "doxygen" target that can be used to transform the source code
documentation into a set of HTML files. The target uses a shell script that
assumes that Doxygen is installed in

  /sw/bin

This is the standard path for the "fink" project. If you have doxygen installed
somewhere else (e.g. /usr/local/bin) you need to change the target's shell
script.

The Doxygen configuration file is located in

  doxygen/Doxyfile

Notes about the configuration:
- Doxygen recursively searches for *.h and *.m files, starting from the project
  base directory.
- Private methods declared in categories in the .m files are not included in
  the documentation process. Change this by setting EXTRACT_LOCAL_METHODS = YES
  inside Doxyfile.
- It is assumed that the command line tool "dot" is available and installed in
    /sw/bin
  dot is part of the Graphviz package and is used to generate a couple of
  diagram types (e.g. class diagrams, collaboration diagrams).


Cocoa topics covered in this project
------------------------------------
dgsmonX wants to be a faceless application (the official name for this is
"agent application"). This requires special configuration in the bundle's
Info.plist (LSUIElement must be set to YES). A property list key reference can
be found in [1]. The application is represented as a status item. The guide for
this is [2].

dgsmonX is quite configurable and has a preference dialog to manage all the
settings. This requires the "User Defaults" system (see [3]) and Cocoa bindings
(see [4], [5] and possibly [6]).

Game state checks are performed in a separate thread so as not to block the GUI
thread during those checks. Basic understanding of how threading and run loops
work can be found in [7]. More details about the mechanism that dgsmonX uses for
thread synchronization (NSConnection and NSPort) may be available in [8].
Scheduling with NSTimer is covered by [9].

Retrieving HTML pages employs the "URL Loading System" which is detailed in
[10].

Game state check results are represented as items inside the menu that pops up
when the dgsmonX status item is clicked. See [11] for information about the
handling of menu items.

[12] explains the nib object lifecycle. This information is helpful for proper
cleanup during application shutdown.


[1]  ADC Home > Reference Library > Guides > Mac OS X > Runtime Configuration Guidelines
[2]  ADC Home > Reference Library > Guides > Cocoa > User Experience > Status Bars
[3]  ADC Home > Reference Library > Guides > Cocoa > User Experience > User Defaults Programming Topics for Cocoa
[4]  ADC Home > Reference Library > Guides > Cocoa > Data Management > Key-Value Coding Programming Guide
[5]  ADC Home > Reference Library > Guides > Cocoa > Design Guidelines > Cocoa Bindings Programming Topics
[6]  ADC Home > Reference Library > Reference > Cocoa > User Experience > Cocoa Bindings Reference
[7]  ADC Home > Reference Library > Guides > Cocoa > Process Management > Threading Programming Guide
[8]  ADC Home > Reference Library > Guides > Cocoa > Interapplication Communication > Distributed Objects Programming Topics
[9]  ADC Home > Reference Library > Guides > Cocoa > Events & Other Input > Timer Programming Topics for Cocoa
[10] ADC Home > Reference Library > Guides > Cocoa > Networking > URL Loading System
[11] ADC Home > Reference Library > Guides > Cocoa > User Experience > Application Menu and Pop-up List Programming Topics for Cocoa
[12] ADC Home > Reference Library > Guides > Cocoa > Resource Management > Resource Programming Guide > Nib Files







3rdparty software
-----------------
Before the first Xcode build of the project is possible, 3rdparty software must
be downloaded and built.

./script/get-and-build-3rdparty-software.sh


Project setup so that it properly uses 3rdparty software
--------------------------------------------------------
TODO. The following is only a rough sketch...

if it's a framework:
* add new group "3rdparty" to project
* add framework reference to project (right-click on "3rdparty" -> Add -> Existing Frameworks... -> Add Other
* right-click on build target -> Get Info -> "Build" tab -> Property "Framework Search Paths" (both configurations) -> change absolute to relative path (remove prefix "$(SRCROOT)/")

if it's a library:
* ???
* possibly interesting link: http://wiki.remobjects.com/wiki/Linking_Custom_Static_Libraries_from_your_iPhone_Xcode_Projects

